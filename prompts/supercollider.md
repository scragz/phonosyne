## SuperCollider Script Structure & Tips

This guide outlines the structure and key considerations for SuperCollider (`.sc`) scripts generated by the Phonosyne SC CompilerAgent. The script will be executed by `sclang`, interacting with an `scsynth` server.

### CRITICAL ADHERENCE DIRECTIVE

All SuperCollider UGen usage within the generated SuperCollider script **must strictly and exclusively conform** to the classes, methods, and parameters as defined in the `Comprehensive SuperCollider UGen Reference` section of this prompt.

---

### A. Script Initialization and Agent-Embedded Variables

**Purpose**: Set up the script environment, create a local variable scope, and define variables based on the input recipe and target output path.

**Structure**:
Your generated SuperCollider script **must** be wrapped in `( { ... }.value )` to create a local scope for your variables and ensure execution.
You (the agent) are responsible for defining the necessary variables at the beginning of this block.

```supercollider
// Your generated script starts here, wrapped in ( { ... }.value ):
(
    Routine { // Wrap entire logic in a top-level Routine
        // --- Values embedded by Phonosyne SC CompilerAgent ---
        // These variables are DEFINED BY YOU (THE AGENT) based on the input recipe
        // and the constructed absolute output path.
        var gAbsoluteOutputWavPath = "/Users/scragz/Projects/phonosyne/output/exec_env_output/MySound_attempt_1.wav"; // Example: Agent constructs and embeds this
        var gRecipeDuration = 5.0;          // Example: Agent embeds from recipe_json.duration
        var gEffectName = "MyCoolEffect";     // Example: Agent embeds from recipe_json.effect_name
        // ... other synthesis parameters as SC variables ...
        // --- End Embedded Values ---

        // Ensure server is running before proceeding
        if (server.serverRunning.not) {
            "SC: Server not running, attempting to boot...".postln;
            server.bootSync; // Boot and wait for completion - now inside a Routine
            "SC: Server booted.".postln;
        } {
            "SC: Server already running.".postln;
        };

        // Your script logic (sections B, C, D below) goes here...

    }.value // Execute the function block
)
// End of your generated script
```

This explicitly tells the agent its responsibility for defining these variables within the SC code it generates.

---

### B. Agent-Embedded Synthesis Parameters

**Purpose**: Inject values from the `recipe_json` into the SuperCollider script as local variables within your script's main function scope. This is now covered by the updated Section A. Ensure all parameters from `recipe_json` (like `p_frequency`, `p_amplitude`, `p_attackTime`, `p_releaseTime`) are defined as SC variables in Section A.

**Calculate `p_sustainTime`**:
Within your SC script's variable definition area (Section A), after defining `p_attackTime` and `p_releaseTime` from the recipe, and using `gRecipeDuration`, calculate `p_sustainTime`:

```supercollider
        // (Still inside the { ... } block, after other var definitions)
        var p_sustainTime = max(0.001, gRecipeDuration - p_attackTime - p_releaseTime); // Ensure positive, non-zero sustain
```

**Server Reference**:

```supercollider
var server = s; // Or Server.default; (Still inside the { ... } block)
```

**Important Tips**:

- Use the SC variables you defined (e.g., `gAbsoluteOutputWavPath`, `gRecipeDuration`, `gEffectName`, `p_frequency`, `p_amplitude`, `p_attackTime`, `p_sustainTime`, `p_releaseTime`) directly in your `SynthDef` and `Synth` creation logic.
- `gRecipeDuration` is the total duration for recording. Use it to calculate envelope segment times accurately, especially `p_sustainTime`.
- `gAbsoluteOutputWavPath` is the **critical** path for `s.prepareForRecord`.

---

### C. SynthDef Creation

**Purpose**: Define the synthesis algorithm (the "instrument").

**Structure (inside the `{ ... }` block, after variable declarations)**:

```supercollider
SynthDef(gEffectName ++ "_SynthDef", { |outBus = 0, gate = 1, masterAmp = 0.1, freq = 440, attackTime = 0.01, sustainTime = 1.0, releaseTime = 0.5|
    var signal, envelope;

    // Envelope: Using Env.new for precise ADSR segment control.
    // Levels: Start at 0, peak to 1 (scaled by masterAmp), sustain at 1, release to 0.
    // Times: Durations for attack, sustain, and release segments.
    envelope = EnvGen.kr(
        Env.new([0, 1, 1, 0], [attackTime, sustainTime, releaseTime], curve: -4.0),
        gate, // Gate controls the progression through the envelope
        levelScale: masterAmp,
        doneAction: Done.freeSelf // Crucial: frees the synth when envelope is done
    );

    // Signal Chain (example: simple sine wave)
    signal = SinOsc.ar(freq);
    signal = signal * envelope;

    // MANDATORY: Apply .tanh() to the final signal before output
    signal = signal.tanh;

    // Output: Mono to the specified output bus (usually 0 for recording main out)
    Out.ar(outBus, signal);
}).add; // Add the SynthDef to the server

// Note: SynthDef.add is generally blocking on a local server.
// No server.sync is needed here if this code is not inside a Routine.
// If issues arise with SynthDef not being ready (e.g., on a remote/latent server),
// more complex asynchronous SynthDef loading might be required.
```

**Important Tips**:

- **SynthDef Naming**: Use `gEffectName` (from tool) to create a reasonably unique SynthDef name (e.g., `gEffectName ++ "_SynthDef"`).
- **Parameters**: Define `SynthDef` arguments for `attackTime`, `sustainTime`, and `releaseTime` to be controlled by the calculated `p_attackTime`, `p_sustainTime`, `p_releaseTime`.
- **Envelope is Key (`Env.new`)**:
  - Use `Env.new([0, 1, 1, 0], [attackSegmentDuration, sustainSegmentDuration, releaseSegmentDuration], curve: -4.0)` for a standard ADSR shape where sustain is held at peak level.
  - `doneAction: Done.freeSelf` on `EnvGen.kr` is essential for freeing the synth.
- **`.tanh`**: Always apply `.tanh` to the signal just before `Out.ar`.
- **Output**: Use `Out.ar(0, signal)` for mono output.

---

### D. Recording Logic and Synth Playback

**Purpose**: Record the audio generated by the SynthDef to the specified WAV file. This logic **must** be inside a `Routine`.

**Structure (inside the `{ ... }` block, after SynthDef creation)**:

```supercollider
// This Routine is for recording and synth playback.
// It assumes the server is booted and SynthDef is added,
// which should be handled by an outer Routine or setup block.
Routine {
    // Define a target sample rate, e.g., for calculating recBufSize if needed,
    // though actual recording sample rate is usually set by server options.
    var targetSampleRate = 48000;

    // 1. Set server's recorder properties BEFORE calling prepareForRecord.
    // This ensures the server's recorder instance uses these specific settings.
    server.recChannels = 1;               // Mono recording
    server.recHeaderFormat = "WAV";       // WAV file format
    server.recSampleFormat = "float";     // 32-bit float sample format
    // recBufSize must be a power of two.
    // Using targetSampleRate.nextPowerOfTwo (e.g., 65536 for 48kHz) is a common practice.
    server.recBufSize = targetSampleRate.nextPowerOfTwo;

    // 2. Prepare for Recording
    // Use the gAbsoluteOutputWavPath (defined by the agent in the main script block)
    // and the number of channels.
    server.prepareForRecord(gAbsoluteOutputWavPath, 1); // path, numChannels
    server.sync; // Wait for preparation to complete (safe inside this Routine)

    // 3. Start Recording
    server.record;
    server.sync; // Ensure recording has started (safe inside this Routine)

    // 4. Play the Synth
    // Assumes gEffectName, p_amplitude, p_frequency, p_attackTime,
    // p_sustainTime, and p_releaseTime are defined in the outer scope
    // (e.g., the main script block by the agent).
    Synth(gEffectName ++ "_SynthDef", [
        \masterAmp: p_amp,          // Use agent-embedded variable for amplitude
        \freq: p_freq,              // Use agent-embedded variable for frequency
        \attackTime: p_attack,      // Use agent-embedded variable
        \sustainTime: p_sustain,    // Use agent-calculated sustain duration
        \releaseTime: p_release     // Use agent-embedded variable
        // gate defaults to 1; EnvGen with doneAction: Done.freeSelf handles envelope lifecycle and freeing.
    ]);

    // 5. Wait for the total duration of the sound
    // gRecipeDuration (defined by the agent) should align with the
    // total envelope duration (p_attackTime + p_sustainTime + p_releaseTime).
    gRecipeDuration.wait;

    // 6. Stop Recording
    server.stopRecording;
    server.sync; // Ensure recording is finalized and file is written (safe inside this Routine)

    ("SuperCollider: Recording complete for " ++ gAbsoluteOutputWavPath).postln;

    // Quit sclang after a short delay to allow messages to flush
    (0.1).wait;
    "SC: Script finished. Quitting sclang.".postln;
    0.exit;
}.play(AppClock); // Play the routine; AppClock is typical for timed operations.
```

**Important Tips**:

- **Use `Routine`**: All server interaction for recording and playback (including `server.sync` and `.wait`) must be within a `Routine`.
- **`server.prepareForRecord`**: Specify mono, 48000 Hz, WAV, float. **Use `gAbsoluteOutputWavPath`**.
- **`server.sync` (inside Routine)**: Use after critical server commands like `prepareForRecord`, `record`, `stopRecording` _within the Routine_ to ensure sequential execution.
- **Synth Instantiation**: Pass the agent-embedded and calculated parameters (like `p_frequency`, `p_amplitude`, `p_attackTime`, `p_sustainTime`, `p_releaseTime`) to the `SynthDef` arguments.
- **Duration Alignment**: The `gRecipeDuration.wait;` call should correspond to the total duration of the envelope defined by `p_attackTime + p_sustainTime + p_releaseTime`. The calculation of `p_sustainTime` from `gRecipeDuration` ensures this.

---

### E. Important Coding Rules

IT IS CRITICAL TO FOLLOW THESE RULES. Failure to follow these rules will lead to errors in the generated SuperCollider script.

- **Declare ALL function variables**: At the start of your script (inside the `{ ... }` block) and at the beginning of each block, declare ALL `var`s BEFORE any other operations or it WILL THROW AN ERROR.
- **Multiple by -1 for negative variables**: If you need to invert a variable (e.g., for phase), use `-1 * variableName` instead of `-variableName`. `-variableName` WILL THROW AN ERROR.
- **Boot the server**: Always check if the server is running and boot it if not. Use `server.bootSync` to ensure it is ready before proceeding.

---

### F. Full Script Example (Conceptual)

This illustrates how the agent-generated script would look, incorporating the above guidelines. Remember the tool prepends global-like variables.

```supercollider
var gAbsoluteOutputWavPath = "/tmp/_sctemp/MySound_attempt_1.wav";
var gRecipeDuration = 3.0; // Total duration for recording & envelope
var gEffectName = "MySound";

(
    Routine { // Wrap entire logic in a top-level Routine
        // Agent-embedded parameters from recipe_json
        var p_freq = 440.0;
        var p_amp = 0.2;
        var p_attack = 0.05;    // Attack segment duration
        var p_release = 0.8;   // Release segment duration

        var p_sustain;
        var server;

        // Calculate sustain segment duration to make total envelope duration = gRecipeDuration
        p_sustain = max(0.001, gRecipeDuration - p_attack - p_release); // ensure positive

        server = Server.default; // Use 'Server.default' for clarity, often aliased to 's'

        // Ensure server is running before proceeding
        if (server.serverRunning.not) {
            "SC: Server not running, attempting to boot...".postln;
            server.bootSync; // Boot and wait for completion - now inside a Routine
            "SC: Server booted.".postln;
        } {
            "SC: Server already running.".postln;
        };

        SynthDef(gEffectName ++ "_SynthDef", { |outBus = 0, gate = 1, masterAmp = 0.1, freq = 440, attackTime = 0.01, sustainTime = 1.0, releaseTime = 0.5|
            var signal, envelope;
            envelope = EnvGen.kr(
                Env.new([0, 1, 1, 0], [attackTime, sustainTime, releaseTime], curve: -4.0),
                gate,
                levelScale: masterAmp,
                doneAction: Done.freeSelf
            );
            signal = SinOsc.ar(freq);
            signal = signal * envelope;
            signal = signal.tanh; // MANDATORY tanh
            Out.ar(outBus, signal);
        }).add; // This now happens after server boot check

        // SynthDef.add is blocking on local server, no server.sync needed here outside a Routine.

        // This inner Routine for recording remains, and will be scheduled correctly
        // as part of the outer Routine's execution flow.
        Routine {
            var targetSampleRate = 48000; // Define intended sample rate

            // Set server's recorder properties before calling prepareForRecord
            server.recChannels = 1;
            server.recHeaderFormat = "WAV";
            server.recSampleFormat = "float";
            server.recBufSize = targetSampleRate.nextPowerOfTwo; // e.g., 65536 for 48kHz

            // Corrected prepareForRecord call
            server.prepareForRecord(gAbsoluteOutputWavPath, 1); // path, numChannels
            server.sync;
            server.record;
            server.sync;

            Synth(gEffectName ++ "_SynthDef", [
                \masterAmp: p_amp,
                \freq: p_freq,
                \attackTime: p_attack,
                \sustainTime: p_sustain, // Pass the calculated sustain segment duration
                \releaseTime: p_release
            ]);

            // Wait for the total recipe duration, which matches the envelope's total duration
            gRecipeDuration.wait;

            server.stopRecording;
            server.sync;
            ("SC: Done: " ++ gAbsoluteOutputWavPath).postln;

            // Quit sclang after a short delay to allow messages to flush
            (0.1).wait;
            "SC: Script finished. Quitting sclang.".postln;
            0.exit;
        }.play(AppClock); // This inner routine is played on AppClock as before

    }.play(AppClock); // Play the new top-level Routine
)
```

---

## Appendix: Comprehensive SuperCollider UGen Reference

This section provides a reference for SuperCollider Unit Generators (UGens) that can be used in the generated scripts. All UGen usage **must strictly and exclusively conform** to the classes, methods, and parameters as defined here (using SuperCollider syntax, e.g., `SinOsc.ar(frequency, phase)`). Use the `.ar()` method for audio-rate signals and `.kr()` for control-rate signals where applicable. Parameters shown are typical; refer to SuperCollider documentation for exhaustive details. Argument names are generally lowercase in SCdoc style (e.g. `freq` or `frequency`, `mul`, `add`).

**Important Note on `input` (or first) argument:** Many UGens take an `input` signal (often the first argument, sometimes named `in`). This will be the output of an upstream UGen. For mono operation as generally required, this will be a single UGen instance.

---

### Envelopes (`Env` class methods and `EnvGen`)

_(The `Env` class creates envelope shape data objects used by `EnvGen`.)_

- `Env.adsr(attackTime: 0.01, decayTime: 0.3, sustainLevel: 0.5, releaseTime: 1.0, peakLevel: 1.0, curve: -4.0, bias: 0.0)`: Standard ADSR envelope.
- `Env.asr(attackTime: 0.01, sustainLevel: 1.0, releaseTime: 1.0, curve: -4.0)`: Attack-Sustain-Release envelope.
- `Env.perc(attackTime: 0.01, releaseTime: 1.0, level: 1.0, curve: -4.0)`: Percussive envelope.
- `Env.linen(attackTime: 0.01, sustainTime: 1.0, releaseTime: 1.0, level: 1.0, curve: 'lin')`: Linen (trapezoidal) envelope.
- `Env.triangle(duration: 1.0, level: 1.0)`: Triangle-shaped envelope.
- `Env.sine(duration: 1.0, level: 1.0)`: Sine-shaped envelope.
- `Env.new(levels: [0, 1, 0], times: [0.1, 1.0], curve: -4.0, releaseNode, loopNode, offset)`: Envelope from explicit segments.

---

### Oscillators

- `SinOsc.ar(freq: 440.0, phase: 0.0, mul: 1.0, add: 0.0)`: Sinusoid oscillator.
- `FSinOsc.kr(freq: 440.0, iphase: 0.0, mul: 1.0, add: 0.0)`: Fast sine oscillator (optimized for control rate, but can be `.ar`).
- `LFTri.ar(freq: 440.0, iphase: 0.0, mul: 1.0, add: 0.0)`: Non-band-limited triangle oscillator. (Often `.kr` for LFO).
- `LFSaw.ar(freq: 440.0, iphase: 0.0, mul: 1.0, add: 0.0)`: Non-band-limited sawtooth oscillator. (Often `.kr` for LFO). Also covers `Saw.ar` from the book for basic sawtooth.
- `LFPulse.ar(freq: 440.0, iphase: 0.0, width: 0.5, mul: 1.0, add: 0.0)`: Non-band-limited pulse oscillator. (Often `.kr` for LFO).
- `LFPar.kr(freq: 440.0, iphase: 0.0, mul: 1.0, add: 0.0)`: Low-frequency parabolic oscillator. (Typically `.kr` for LFO).
- `VarSaw.ar(freq: 440.0, iphase: 0.0, width: 0.5, mul: 1.0, add: 0.0)`: Variable-duty (non-band-limited) sawtooth oscillator.
- `Blip.ar(freq: 440.0, numharm: 200, mul: 1.0, add: 0.0)`: Band-limited impulse train, rich in harmonics.
- `Impulse.ar(freq: 440.0, phase: 0.0, mul: 1.0, add: 0.0)`: Single-sample impulse generator.
- `LFGauss.ar(duration: 1.0, width: 0.1, iphase: 0.0, loop: 1, doneAction: 0, mul: 1.0, add: 0.0)`: Gaussian function oscillator.

---

### Noise Generators

- `WhiteNoise.ar(mul: 1.0, add: 0.0)`: White noise.
- `PinkNoise.ar(mul: 1.0, add: 0.0)`: Pink noise.
- `BrownNoise.ar(mul: 1.0, add: 0.0)`: Brown noise.
- `GrayNoise.ar(mul: 1.0, add: 0.0)`: Gray noise.
- `Crackle.ar(chaosParam: 1.5, mul: 1.0, add: 0.0)`: Chaotic noise.
- `Dust.ar(density: 20.0, mul: 1.0, add: 0.0)`: Unipolar random impulses. `density` is average impulses per second.
- `Dust2.ar(density: 20.0, mul: 1.0, add: 0.0)`: Bipolar random impulses. `density` is average impulses per second.
- `LFNoise0.kr(freq: 500.0, mul: 1.0, add: 0.0)`: Step noise (random levels held for `1/freq` seconds).
- `LFNoise1.kr(freq: 500.0, mul: 1.0, add: 0.0)`: Ramp noise (random slopes, new target value every `1/freq` seconds).

---

### Input

- `In.ar(bus: 0, numChannels: 1)`: Reads an audio signal from a bus.
- `AudioIn.ar(bus: 0, numChannels: 1)`: Reads audio from the server's audio inputs (e.g., microphone). (Typically `numChannels` matches hardware).
- `SoundIn.ar(bus: 0, mul: 1.0, add: 0.0)`: Reads audio input from the ADC. (Arguments can vary; often `bus` refers to an array of input channels, e.g., `SoundIn.ar([0,1])` for stereo).
- `LocalIn.ar(numChannels: 1, mul: 1.0, add: 0.0)`: Reads from a local bus (feedback within a Synth).

---

### Buffer & Sampling

- `PlayBuf.ar(numChannels, bufnum, rate: 1.0, trigger: 1.0, startPos: 0.0, loop: 0.0, doneAction: 0, mul: 1.0, add: 0.0)`: Plays back a sound buffer.
- `BufRateScale.kr(bufnum, mul: 1.0, add: 0.0)`: Returns the rate scaler for a buffer to play at its original pitch.
- `LocalBuf.new(numFrames: 2048, numChannels: 1)`: Allocates a buffer local to the Synth. (Used for FFT, delays, etc. Not a UGen with `.ar` or `.kr` in this context of allocation).
- `Osc.ar(bufnum, freq: 440.0, phase: 0.0, mul: 1.0, add: 0.0)`: Interpolating wavetable oscillator. (Requires a buffer `bufnum` containing a single cycle waveform).

---

### Envelope Generators & Control Signals

- `EnvGen.kr(envelope, gate: 1.0, levelScale: 1.0, levelBias: 0.0, timeScale: 1.0, doneAction: 0, mul: 1.0, add: 0.0)`: Envelope generator. (`envelope` is an `Env` object. `doneAction: Done.freeSelf` is common). `EnvGen.ar` is also possible for audio-rate envelopes.
- `Line.kr(start: 0.0, end: 1.0, dur: 1.0, doneAction: 0, mul: 1.0, add: 0.0)`: Linear ramp.
- `XLine.kr(start: 1.0, end: 0.001, dur: 1.0, doneAction: 0, mul: 1.0, add: 0.0)`: Exponential ramp.
- `Phasor.ar(trig: 0.0, rate: 1.0, start: 0.0, end: 1.0, resetPos: 0.0, mul: 1.0, add: 0.0)`: Resettable linear ramp (0 to `end` scaled by `rate` per second).
- `MouseX.kr(minval: 0.0, maxval: 1.0, warp: 0, lag: 0.2, mul: 1.0, add: 0.0)`: Control signal from mouse X-axis position.
- `MouseY.kr(minval: 0.0, maxval: 1.0, warp: 0, lag: 0.2, mul: 1.0, add: 0.0)`: Control signal from mouse Y-axis position.

---

### Filters

- `LPF.ar(in, freq: 440.0, mul: 1.0, add: 0.0)`: Lowpass filter (2-pole).
- `HPF.ar(in, freq: 440.0, mul: 1.0, add: 0.0)`: Highpass filter (2-pole).
- `BPF.ar(in, freq: 440.0, rq: 1.0, mul: 1.0, add: 0.0)`: Bandpass filter (rq is reciprocal of Q).
- `BRF.ar(in, freq: 440.0, rq: 1.0, mul: 1.0, add: 0.0)`: Band-reject filter.
- `RLPF.ar(in, freq: 440.0, rq: 1.0, mul: 1.0, add: 0.0)`: Resonant lowpass filter.
- `RHPF.ar(in, freq: 440.0, rq: 1.0, mul: 1.0, add: 0.0)`: Resonant highpass filter.
- `Resonz.ar(in, freq: 440.0, bwr: 0.5, mul: 1.0, add: 0.0)`: Resonant filter. `bwr` is bandwidth ratio (Q = 1/bwr).
- `SOS.ar(in, a0: 1.0, a1: 0.0, a2: 0.0, b1: 0.0, b2: 0.0, mul: 1.0, add: 0.0)`: Second Order Section (biquad) filter with direct coefficient control.
- `MoogFF.ar(in, freq: 100.0, gain: 2.0, reset: 0.0, mul: 1.0, add: 0.0)`: Moog VCF (Voltage Controlled Filter) emulation.
- `Formlet.ar(in, freq: 440.0, attacktime: 0.01, decaytime: 0.1, mul: 1.0, add: 0.0)`: FOF-like (formant) filter.
- `OnePole.ar(in, coef: 0.5, mul: 1.0, add: 0.0)`: One pole filter. `coef` close to 1 is lowpass, -1 highpass.
- `OneZero.ar(in, coef: 0.5, mul: 1.0, add: 0.0)`: One zero filter.
- `LeakDC.ar(in, coef: 0.995, mul: 1.0, add: 0.0)`: DC blocking filter (a simple high-pass).
- `Ringz.ar(in, freq: 440.0, decaytime: 1.0, mul: 1.0, add: 0.0)`: Ringing filter (resonator).

---

### Delays & Comb Filters

- `DelayN.ar(in, maxdelaytime: 0.2, delaytime: 0.2, mul: 1.0, add: 0.0)`: No-interpolation delay.
- `DelayL.ar(in, maxdelaytime: 0.2, delaytime: 0.2, mul: 1.0, add: 0.0)`: Linear-interpolation delay.
- `DelayC.ar(in, maxdelaytime: 0.2, delaytime: 0.2, mul: 1.0, add: 0.0)`: Cubic-interpolation delay.
- `CombN.ar(in, maxdelaytime: 0.2, delaytime: 0.2, decaytime: 1.0, mul: 1.0, add: 0.0)`: No-interpolation comb filter.
- `CombL.ar(in, maxdelaytime: 0.2, delaytime: 0.2, decaytime: 1.0, mul: 1.0, add: 0.0)`: Linear-interpolation comb filter.
- `CombC.ar(in, maxdelaytime: 0.2, delaytime: 0.2, decaytime: 1.0, mul: 1.0, add: 0.0)`: Cubic-interpolation comb filter.
- `AllpassN.ar(in, maxdelaytime: 0.2, delaytime: 0.2, decaytime: 1.0, mul: 1.0, add: 0.0)`: No-interpolation allpass filter.
- `AllpassL.ar(in, maxdelaytime: 0.2, delaytime: 0.2, decaytime: 1.0, mul: 1.0, add: 0.0)`: Linear-interpolation allpass filter.
- `AllpassC.ar(in, maxdelaytime: 0.2, delaytime: 0.2, decaytime: 1.0, mul: 1.0, add: 0.0)`: Cubic-interpolation allpass filter.

---

### Dynamics

- `Compander.ar(in, control: 0.0, thresh: 0.5, slopeBelow: 1.0, slopeAbove: 1.0, clampTime: 0.01, relaxTime: 0.1, mul: 1.0, add: 0.0)`: Compressor/expander/gate. `control` is usually `in`.
- `Limiter.ar(in, level: 1.0, dur: 0.01, mul: 1.0, add: 0.0)`: Peak limiter with lookahead (`dur`).
- `Normalizer.ar(in, level: 1.0, dur: 0.01, mul: 1.0, add: 0.0)`: Dynamics flattener / lookahead normalizer.
- `Amplitude.kr(input, attackTime: 0.01, releaseTime: 0.01, mul: 1.0, add: 0.0)`: Amplitude follower.

---

### Pitch & Analysis

- `Pitch.kr(in, initFreq: 440, minFreq: 60, maxFreq: 4000, execFreq: 100, maxBinsPerOctave: 16, median: 1, ampThreshold: 0.01, peakThreshold: 0.5, downSample: 1, clar: 0, mul: 1.0, add: 0.0)`: Pitch tracker. Returns `[freq, hasFreq]`.
- `Tartini.kr(in, size: 1024, hop: 0.5, minSaliency: 0.2, overlap: 4, mul: 1.0, add: 0.0)`: Pitch tracker (external SC3-plugins). Returns `[freq, hasFreq]`.

---

### Math & Utility

- `Clip.ar(in, lo: 0.0, hi: 1.0, mul: 1.0, add: 0.0)` or `in.clip(lo, hi)`: Clips signal.
- `Fold.ar(in, lo: 0.0, hi: 1.0, mul: 1.0, add: 0.0)` or `in.fold(lo, hi)`: Folds signal.
- `Wrap.ar(in, lo: 0.0, hi: 1.0, mul: 1.0, add: 0.0)` or `in.wrap(lo, hi)`: Wraps signal.
- `Lag.kr(in, lagTime: 0.1, mul: 1.0, add: 0.0)` or `in.lag(lagTime)`: Lag generator (exponential smoothing).
- `Mix.new(arrayOfSignalsOrFunction)` or `Mix(arrayOfSignals)`: Sums an array of signals. If function, it's evaluated to generate signals. Often used as `Mix.ar { ... }` or `(sig1 + sig2 + sig3)`. For simple summing, `+` operator or `sig.sum` on an array is also common. A direct `Mix.ar` UGen doesn't exist; it's a class method that often returns an `Sum4` or similar optimized summer, or just an array sum. For this reference, `Mix.new([...])` is a good representation.
- `Schmidt.kr(in, lo: 0.0, hi: 1.0, mul: 1.0, add: 0.0)`: Schmidt trigger (hysteresis).
- `Rand(0.0, 1.0)`: Uniform random number (init-rate, generated once when SynthDef is built).
- `TRand.kr(lo: 0.0, hi: 1.0, trig: 0.0, mul: 1.0, add: 0.0)`: Triggered random number (new value when `trig` transitions from non-positive to positive).

---

### Panning & Spatialization

- `Pan2.ar(in, pos: 0.0, level: 1.0, mul: 1.0, add: 0.0)`: Equal-power two-channel panner.
- `LinPan2.ar(in, pos: 0.0, level: 1.0, mul: 1.0, add: 0.0)`: Linear two-channel panner.
- `Balance2.ar(left, right, pos: 0.0, level: 1.0, mul: 1.0, add: 0.0)`: Stereo balance (adjusts levels of left/right inputs).
- `XFade.ar(inA, inB, pan: 0.0, level: 1.0, mul: 1.0, add: 0.0)`: Equal-power crossfader. `pan` is crossfade position (-1 for inA, 1 for inB).

---

### Reverbs

- `FreeVerb.ar(in, mix: 0.33, room: 0.5, damp: 0.5, mul: 1.0, add: 0.0)`: Schroeder reverberator (popular, versatile).
- `GVerb.ar(in, roomsize: 10.0, revtime: 3.0, damping: 0.5, inputbw: 0.5, spread: 15.0, drylevel: 1.0, earlyreflevel: 0.7, taillevel: 0.5, maxroomsize: 300.0, mul: 1.0, add: 0.0)`: Schroeder reverberator with more detailed controls.

---

### Frequency Domain Effects (FFT)

_(Note: FFT effects involve a chain: `FFT` -> `PV_UGen(s)` -> `IFFT`. `LocalBuf` is used to create the buffer for FFT data. PV_UGens typically return a new FFT chain, not an audio signal directly.)_

- `FFT.new(buffer, in, hop: 0.5, wintype: 0, winsize: 0)`: Performs Fast Fourier Transform. `buffer` is a `LocalBuf`. `wintype` 0 is Hann, 1 is sine. `winsize` 0 means buffer size. Returns an FFT chain.
- `IFFT.new(chain, wintype: 0, winsize: 0)`: Performs Inverse Fast Fourier Transform. Converts FFT data back to time domain. (This UGen will have `.ar` implicitly when used to generate sound).

#### Phase Vocoder (PV\_) UGens (operate on FFT chains)

- `PV_MagAbove.new(chain, threshold: 0.0)`: Passes bins whose magnitudes are above a threshold.
- `PV_BrickWall.new(chain, wipe: 0.0)`: Clears bins above (`wipe` > 0) or below (`wipe` < 0) a cutoff point (fraction of Nyquist).
- `PV_RectComb.new(chain, numTeeth: 8, phase: 0.0, width: 0.5)`: Creates a series of gaps (teeth) in the spectrum.
- `PV_MagFreeze.new(chain, freeze: 0.0)`: Freezes magnitudes when `freeze` > 0.
- `PV_CopyPhase.new(chainA, chainB)`: Combines magnitudes of `chainA` with phases of `chainB`.
- `PV_MagSmear.new(chain, bins: 1.0)`: Averages a bin's magnitude with its `bins` neighbours. (bins is float 0-1 for proportion of window)
- `PV_Morph.new(chainA, chainB, morphPos: 0.0)`: Morphs magnitudes and phases between two FFT chains. `morphPos` from 0 (A) to 1 (B).
- `PV_XFade.new(chainA, chainB, xfadePos: 0.0)`: Interpolates (crossfades) bins between two FFT chains. `xfadePos` from 0 (A) to 1 (B).
- `PV_SoftWipe.new(chainA, chainB, wipePos: 0.0)`: Copies low bins from `chainA` and high bins from `chainB`, with `wipePos` as the crossover.
- `PV_MagMinus.new(chainA, chainB)`: Subtracts `chainB`'s magnitudes from `chainA`'s.

---

### Output

- `Out.ar(bus: 0, channelsArray)`: Output UGen. For mono: `Out.ar(0, signal)`. For stereo: `Out.ar(0, [leftSignal, rightSignal])`.
- `ReplaceOut.ar(bus: 0, channelsArray)`: Overwrites bus content.
- `OffsetOut.ar(bus: 0, channelsArray)`: Adds to bus content (mixes with existing signal on the bus).
- `LocalOut.ar(channelsArray, mul: 1.0, add: 0.0)`: Writes to a local bus (feedback within a Synth).

---
