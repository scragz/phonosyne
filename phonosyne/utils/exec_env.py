"""
Execution Environment for Dynamically Generated Code

This module provides a secure environment for executing Python code generated by Phonosyne agents
using smolagents.LocalPythonExecutor to analyze AST and restrict operations/imports.

Key features:
- `run_code` function to execute a string of Python code.
- Authorizes specific imports (numpy, scipy, soundfile, math, random).
- Expects the executed code to write audio data directly to the specified output file.
- Verifies the file exists and returns its path after execution.

@dependencies
- `smolagents.local_python_executor.LocalPythonExecutor`
- `numpy` (for DSP operations in generated code)
- `soundfile` (for writing the WAV file in generated code)
- `pathlib.Path`, `typing`, `logging`
- `phonosyne.settings`

@notes
- The generated code must write the audio file directly using the provided output_filename.
- The system verifies the file exists after execution.
"""

import json
import logging
import subprocess
import tempfile
from pathlib import Path

import numpy as np

from phonosyne import settings

logger = logging.getLogger(__name__)

# <<< BEGIN MONKEY PATCH FOR scipy.sparse.coo.upcast >>>
# This patch is to support LLM-generated code that might still refer to
# scipy.sparse.coo.upcast, which has been removed from modern SciPy versions.
# We attempt to add it to the underlying scipy.sparse._coo module.
_monkey_patch_logger = logging.getLogger(__name__ + ".monkey_patch")

try:
    import scipy.sparse._coo as scipy_coo_module

    # numpy is imported as np above

    if not hasattr(scipy_coo_module, "upcast"):

        def _upcast_shim(*args):
            """
            Shim for the removed scipy.sparse.coo.upcast.
            Returns the nearest common type of a sequence of dtypes.
            Based on numpy.find_common_type.
            """
            dtype_objects = [np.dtype(arg) for arg in args]
            return np.find_common_type(dtype_objects, [])

        scipy_coo_module.upcast = _upcast_shim
        _monkey_patch_logger.info(
            "Successfully monkey-patched scipy.sparse._coo.upcast to restore functionality "
            "for LLM-generated code."
        )
    else:
        _monkey_patch_logger.info(
            "scipy.sparse._coo.upcast already exists. No monkey patch applied."
        )
except ImportError:
    _monkey_patch_logger.warning(
        "Could not import scipy.sparse._coo to attempt monkey-patching for upcast. "
        "If LLM-generated code relies on a patched scipy.sparse.coo.upcast, it may fail."
    )
except Exception as e:
    _monkey_patch_logger.error(
        f"An unexpected error occurred while trying to monkey-patch scipy.sparse._coo.upcast: {e}",
        exc_info=True,
    )


class CodeExecutionError(Exception):
    """Custom exception for errors during code execution or processing."""

    pass


class SecurityException(CodeExecutionError):  # Keep for compatibility if used elsewhere
    """Custom exception for security-related issues."""

    pass


def run_supercollider_code(
    code: str,
    output_filename: str,
    recipe_duration: float = 15.0,
    effect_name: str | None = None,
    sclang_path: str = "sclang",
) -> Path:
    """
    Executes SuperCollider code that writes a .wav file and returns its path.

    The SuperCollider code is expected to handle its own server interaction (e.g.,
    booting if necessary, though for now a running server is assumed), synthesis,
    and writing audio data directly to a file at the specified output_filename.
    This function writes the code to a temporary .scd file, executes it using sclang,
    verifies the output file exists, and returns its path.

    Args:
        code: The SuperCollider code string to execute.
        output_filename: Absolute path for the output .wav file. The SC script
                         must write to this exact path.
        recipe_duration: The target duration in seconds for the audio.
        effect_name: Optional name for the effect.
        sclang_path: Path to the sclang executable.

    Returns:
        Path to the generated .wav file.

    Raises:
        CodeExecutionError: If code execution fails, sclang is not found,
                            or the output file doesn't exist.
    """
    logger.info(f"Executing SuperCollider code for target output: '{output_filename}'")
    code_to_log = code[:500] + "..." if len(code) > 500 else code
    logger.debug(f"SuperCollider code (first 500 chars):\\n{code_to_log}")
    logger.debug(f"Target duration for context: {recipe_duration}s")
    logger.debug(f"Effect name for context: {effect_name}")

    actual_wav_path = Path(output_filename)
    if not actual_wav_path.is_absolute():
        err_msg = f"output_filename '{output_filename}' must be an absolute path."
        logger.error(err_msg)
        raise CodeExecutionError(err_msg)

    # Ensure parent directory for the output .wav file exists
    try:
        actual_wav_path.parent.mkdir(parents=True, exist_ok=True)
        logger.info(f"Ensured output directory exists: {actual_wav_path.parent}")
    except OSError as e:
        err_msg = f"Could not create parent directory {actual_wav_path.parent} for output file: {e}"
        logger.error(err_msg)
        raise CodeExecutionError(err_msg) from e

    temp_scd_file_path_str: str | None = None
    try:
        # Create a temporary .scd file to hold the SuperCollider code.
        # The CompilerAgent is responsible for ensuring 'code' uses output_filename, recipe_duration etc.
        with tempfile.NamedTemporaryFile(
            mode="w", suffix=".scd", delete=False, encoding="utf-8"
        ) as tmp_f:
            tmp_f.write(code)
            temp_scd_file_path_str = tmp_f.name
        logger.info(
            f"SuperCollider code written to temporary file: {temp_scd_file_path_str}"
        )

        cmd = [sclang_path, temp_scd_file_path_str]
        logger.info(f"Executing command: {' '.join(cmd)}")

        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding="utf-8",
        )
        stdout, stderr = process.communicate()  # Wait for completion

        if process.returncode != 0:
            error_message = (
                f"sclang execution failed for {temp_scd_file_path_str} (targeting {output_filename}).\\n"
                f"Return code: {process.returncode}\\n"
                f"STDOUT:\\n{stdout}\\n"
                f"STDERR:\\n{stderr}"
            )
            logger.error(error_message)
            raise CodeExecutionError(error_message)
        else:
            logger.info(f"sclang execution successful for {temp_scd_file_path_str}.")
            logger.debug(f"sclang STDOUT:\\n{stdout}")
            if stderr:
                logger.debug(f"sclang STDERR:\\n{stderr}")

    except FileNotFoundError:
        err_msg = f"sclang executable not found at '{sclang_path}'. Please ensure SuperCollider is installed and sclang is in your PATH or provide the correct path."
        logger.error(err_msg)
        raise CodeExecutionError(err_msg)
    except Exception as e:
        error_message = f"An unexpected error occurred during SuperCollider code execution for {output_filename}: {e}"
        logger.error(error_message, exc_info=True)
        raise CodeExecutionError(error_message) from e
    finally:
        if temp_scd_file_path_str and Path(temp_scd_file_path_str).exists():
            try:
                Path(temp_scd_file_path_str).unlink()
                logger.info(
                    f"Successfully deleted temporary .scd file: {temp_scd_file_path_str}"
                )
            except OSError as e_unlink:
                logger.warning(
                    f"Could not delete temporary .scd file {temp_scd_file_path_str}: {e_unlink}"
                )

    if not actual_wav_path.exists() or not actual_wav_path.is_file():
        error_message = (
            f"SuperCollider script ran but the output .wav file was not found at {actual_wav_path}.\\n"
            f"Check sclang STDOUT/STDERR above for clues from the script itself."
        )
        logger.error(error_message)
        raise CodeExecutionError(error_message)

    logger.info(f"Successfully produced WAV file via SuperCollider: {actual_wav_path}")
    return actual_wav_path
