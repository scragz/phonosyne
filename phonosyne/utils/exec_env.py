"""
Execution Environment for Dynamically Generated Code

This module provides environments for executing Python code generated by Phonosyne agents.
It supports different execution modes:
- "local_executor": Uses smolagents.LocalPythonExecutor for safer local execution
                    by analyzing AST and restricting operations/imports.
- "inline": Executes code using `exec()` in the current process. Faster, less safe.

Key features:
- `run_code` function to execute a string of Python code.
- "local_executor" mode:
  - Authorizes specific imports (numpy, scipy, soundfile, math, random).
  - Expects the executed code to return a tuple: (numpy_array, sample_rate).
  - Saves the returned audio data to a .wav file.
- "inline" mode:
  - Executes code directly. Expects code to write to OUTPUT_WAV_PATH. (Legacy behavior)

@dependencies
- `smolagents.local_python_executor.LocalPythonExecutor`
- `numpy` (for type hinting the expected array)
- `soundfile` (for writing the WAV file)
- `tempfile`, `pathlib.Path`, `typing`, `logging`
- `phonosyne.settings`

@notes
- The "local_executor" mode is preferred for security when running LLM-generated code.
- The generated code for "local_executor" mode must `return audio_array, sample_rate`.
- The "inline" mode's file writing expectation is different and might be deprecated.
"""

import array  # Added
import json
import logging
import math  # Added
import random  # Added
import shutil
import tempfile
from pathlib import Path
from typing import Any, Dict, Literal, Tuple

import numpy as np
import scipy  # Added
import soundfile as sf
from smolagents.local_python_executor import InterpreterError, LocalPythonExecutor

from phonosyne import settings

logger = logging.getLogger(__name__)

# <<< BEGIN MONKEY PATCH FOR scipy.sparse.coo.upcast >>>
# This patch is to support LLM-generated code that might still refer to
# scipy.sparse.coo.upcast, which has been removed from modern SciPy versions.
# We attempt to add it to the underlying scipy.sparse._coo module.
_monkey_patch_logger = logging.getLogger(__name__ + ".monkey_patch")

try:
    import scipy.sparse._coo as scipy_coo_module

    # numpy is imported as np above

    if not hasattr(scipy_coo_module, "upcast"):

        def _upcast_shim(*args):
            """
            Shim for the removed scipy.sparse.coo.upcast.
            Returns the nearest common type of a sequence of dtypes.
            Based on numpy.find_common_type.
            """
            dtype_objects = [np.dtype(arg) for arg in args]
            return np.find_common_type(dtype_objects, [])

        scipy_coo_module.upcast = _upcast_shim
        _monkey_patch_logger.info(
            "Successfully monkey-patched scipy.sparse._coo.upcast to restore functionality "
            "for LLM-generated code."
        )
    else:
        _monkey_patch_logger.info(
            "scipy.sparse._coo.upcast already exists. No monkey patch applied."
        )
except ImportError:
    _monkey_patch_logger.warning(
        "Could not import scipy.sparse._coo to attempt monkey-patching for upcast. "
        "If LLM-generated code relies on a patched scipy.sparse.coo.upcast, it may fail."
    )
except Exception as e:
    _monkey_patch_logger.error(
        f"An unexpected error occurred while trying to monkey-patch scipy.sparse._coo.upcast: {e}",
        exc_info=True,
    )
# <<< END MONKEY PATCH FOR scipy.sparse.coo.upcast >>>

# Define a restricted global scope for inline execution (legacy)
RESTRICTED_GLOBALS_INLINE: Dict[str, Any] = {
    "__builtins__": {
        "print": print,
        "range": range,
        "len": len,
        "list": list,
        "dict": dict,
        "str": str,
        "int": int,
        "float": float,
        "bool": bool,
        "True": True,
        "False": False,
        "None": None,
        "abs": abs,
        "round": round,
        "min": min,
        "max": max,
        "sum": sum,
        "pow": pow,
        "Exception": Exception,
    },
}

# Authorized imports for LocalPythonExecutor
# Based on compiler.md: numpy, scipy.signal, soundfile as sf, plus random, math
# os, tempfile, time, json, sys are generally unsafe for LLM code.
# LocalPythonExecutor has its own defaults, we add to them or specify a full list.
# Common safe DSP modules:
AUTHORIZED_IMPORTS_FOR_DSP = [
    "numpy",
    "numpy.*",
    "scipy",
    "scipy.*",
    "math",
    "random",
    "array",
    "json",
    "phonosyne.dsp.effects",  # Allows generated code to 'import phonosyne.dsp.effects as fx' if ever needed for other reasons
    "phonosyne.dsp.effects.*",  # Allows generated code to 'from phonosyne.dsp.effects import some_utility' if ever needed
]


class CodeExecutionError(Exception):
    """Custom exception for errors during code execution or processing."""

    pass


class SecurityException(CodeExecutionError):  # Keep for compatibility if used elsewhere
    """Custom exception for security-related issues."""

    pass


def run_code(
    code: str,
    output_filename: str,
    recipe_description: str = "",
    recipe_duration: float = 15.0,
    recipe_json_str: str = "",
    # Default to "local_executor" if settings.EXECUTION_MODE is "subprocess" (old default)
    mode: Literal["local_executor", "inline"] = (
        "local_executor"
        if settings.EXECUTION_MODE == "subprocess"
        else settings.EXECUTION_MODE
    ),
    # timeout_s is not directly applicable to LocalPythonExecutor, which uses operation count.
    # Keep for "inline" mode or future modes.
    timeout_s: int = settings.COMPILER_TIMEOUT_S,
) -> Path:
    """
    Executes Python code, saves the output as a .wav file, and returns its path.

    For "local_executor" mode:
    - Executes `code` using `LocalPythonExecutor`.
    - The `code` can expect `description` (str) and `duration` (float) to be available in its global scope.
    - `code` MUST return a tuple: `(numpy.ndarray, int)` representing (audio_data, sample_rate).
    - This function then saves the audio_data as a .wav file.

    For "inline" mode (legacy):
    - Executes `code` using `exec()`.
    - `code` is expected to write a .wav file to a path specified by `OUTPUT_WAV_PATH`
      (which is injected into its scope).

    Args:
        code: The Python code string to execute.
        output_filename: Desired name for the output .wav file (e.g., "sample_01.wav").
        recipe_description: The natural language description for synthesis.
        recipe_duration: The target duration in seconds for the audio.
        mode: Execution mode: "local_executor" or "inline".
        timeout_s: Timeout in seconds (currently only relevant for "inline" or future modes).

    Returns:
        Path to the generated .wav file.

    Raises:
        CodeExecutionError: If code execution fails, output is invalid, or file saving fails.
        SecurityException: For security issues (currently from inline mode's legacy path).
        ValueError: If mode is unsupported.
    """
    logger.info(f"Executing code in '{mode}' mode. Target output: {output_filename}")

    # Determine the final directory for the output WAV.
    # exec_env_output is a persistent temporary holding place.
    # The orchestrator should move files from here to the final brief-specific output dir.
    persistent_temp_dir = settings.DEFAULT_OUT_DIR / "exec_env_output"
    persistent_temp_dir.mkdir(parents=True, exist_ok=True)
    # Use a unique name for the actual file to avoid collisions during concurrent runs,
    # then rename or ensure caller uses this unique path.
    # For simplicity, let's use a NamedTemporaryFile pattern but ensure it's in our persistent dir.

    # Create a Path object for the final intended output, but it will be written by this function.
    # The NamedTemporaryFile gives a unique name, then we copy to output_filename.
    # Simpler: just write directly to persistent_temp_dir / output_filename
    # If output_filename needs to be unique per call, caller should ensure that.
    # For now, assume output_filename is sufficiently unique or will be overwritten.
    actual_wav_path = persistent_temp_dir / output_filename

    if mode == "local_executor":
        dsp_effect_tools = {}
        # List of effect names (module names) that should have an apply_<effect_name> function
        effects_to_load = [
            "autowah",
            "chorus",
            "compressor",
            "delay",
            "distortion",
            "dub_echo",
            "echo",
            "flanger",
            "fuzz",
            "long_reverb",
            "noise_gate",
            "overdrive",
            "particle",
            "phaser",
            "rainbow_machine",
            "short_reverb",
            "tremolo",
            "vibrato",
        ]

        for effect_module_name in effects_to_load:
            function_name = f"apply_{effect_module_name}"
            try:
                # Dynamically import the module and get the function
                module = __import__(
                    f"phonosyne.dsp.effects.{effect_module_name}",
                    fromlist=[function_name],
                )
                func = getattr(module, function_name)
                dsp_effect_tools[function_name] = func
            except ImportError as e:
                logger.error(
                    f"Failed to import {function_name} from phonosyne.dsp.effects.{effect_module_name}: {e}"
                )
            except AttributeError as e:
                logger.error(
                    f"Function {function_name} not found in phonosyne.dsp.effects.{effect_module_name}: {e}"
                )
            except Exception as e:
                logger.error(
                    f"Unexpected error loading effect {effect_module_name} ({function_name}): {e}"
                )

        executor = LocalPythonExecutor(
            additional_authorized_imports=AUTHORIZED_IMPORTS_FOR_DSP
        )

        # Prepare tools and common modules to inject into the executor's scope
        all_tools_to_send = {
            "np": np,
            "numpy": np,  # Allow use of 'numpy.array' if AI generates that
            "scipy": scipy,
            "math": math,
            "random": random,
            "array": array,  # The array module
            "json": json,  # json module itself
            "hash": hash,  # Built-in hash function
            # Add other specific, safe built-ins or utilities if needed
        }
        all_tools_to_send.update(
            dsp_effect_tools
        )  # Add all dynamically loaded apply_... functions

        executor.send_tools(all_tools_to_send)

        # Inject recipe-specific variables into the executor's state
        variables_to_send = {
            "output_filename": output_filename,
            "description": recipe_description,
            "duration": recipe_duration,
            "recipe_json": recipe_json_str,  # Make the JSON string available as 'recipe_json'
        }
        executor.send_variables(variables_to_send)
        try:
            # LocalPythonExecutor.__call__ returns a 3-tuple: (output, logs, is_final_answer)
            # The 'output' part is what we expect to be (audio_array, sample_rate).
            code_output, logs, is_final_answer = executor(
                code
            )  # This is the actual execution call
            logger.debug(f"LocalPythonExecutor logs: {logs}")
            if (
                is_final_answer
            ):  # Phonosyne doesn't use final_answer concept from smolagents here
                logger.warning(
                    "LocalPythonExecutor indicated final_answer, which is not expected in this context."
                )

            if code_output is None:
                raise CodeExecutionError(
                    "Code executed with LocalPythonExecutor returned None as its main output. "
                    "Expected a tuple of (audio_array, sample_rate)."
                )

            if not isinstance(code_output, tuple) or len(code_output) != 2:
                raise CodeExecutionError(
                    "Code executed with LocalPythonExecutor did not return a tuple of (audio_array, sample_rate) as its main output."
                    f" Got: {type(code_output)}, Value: {code_output!r}"
                )

            audio_data, sample_rate = code_output

            if not isinstance(audio_data, np.ndarray):
                raise CodeExecutionError(
                    f"Returned audio_data is not a NumPy array. Got: {type(audio_data)}"
                )
            if not isinstance(sample_rate, int):
                raise CodeExecutionError(
                    f"Returned sample_rate is not an integer. Got: {type(sample_rate)}"
                )

            logger.info(
                f"Code executed via LocalPythonExecutor. Returned audio data shape: {audio_data.shape}, sample rate: {sample_rate}."
            )

            # Save the returned audio data to the WAV file
            sf.write(
                actual_wav_path, audio_data, sample_rate, subtype="FLOAT"
            )  # Defaulting to 32-bit float
            logger.info(f"Audio data saved to {actual_wav_path}")

        except InterpreterError as e:  # Specific error from LocalPythonExecutor
            logger.error(f"Error during LocalPythonExecutor execution: {e}")
            raise CodeExecutionError(f"LocalPythonExecutor failed: {e}") from e
        except Exception as e:  # Catch other errors like soundfile write issues
            logger.error(
                f"Error processing result from LocalPythonExecutor: {e}", exc_info=True
            )
            raise CodeExecutionError(
                f"Failed to process or save audio from LocalPythonExecutor: {e}"
            ) from e

    elif mode == "inline":  # Legacy inline mode
        # This mode expects the executed code to write the file itself.
        # It needs a temporary directory setup similar to the old subprocess mode.
        with tempfile.TemporaryDirectory(prefix="phonosyne_inline_") as tmpdir_str:
            tmpdir = Path(tmpdir_str)
            # The inline code expects OUTPUT_WAV_PATH to be where it writes.
            # This path should be inside tmpdir.
            inline_output_wav_path = tmpdir / output_filename

            local_scope = {"OUTPUT_WAV_PATH": str(inline_output_wav_path)}
            exec_globals = {**RESTRICTED_GLOBALS_INLINE, **local_scope}

            logger.debug(
                f"Inline execution with OUTPUT_WAV_PATH: {inline_output_wav_path}"
            )
            try:
                exec(code, exec_globals, local_scope)

                # After exec, check if the file was created at inline_output_wav_path
                if (
                    not inline_output_wav_path.exists()
                    or not inline_output_wav_path.is_file()
                ):
                    raise FileNotFoundError(
                        f"Inline code did not create WAV file at expected temp path: {inline_output_wav_path}"
                    )

                # Copy from temp inline path to the persistent actual_wav_path
                shutil.copy2(inline_output_wav_path, actual_wav_path)
                logger.info(
                    f"Inline execution successful. Copied WAV to {actual_wav_path}"
                )

            except Exception as e:
                logger.error(f"Error during inline execution: {e}", exc_info=True)
                raise CodeExecutionError(f"Inline execution failed: {e}") from e
    else:
        raise ValueError(f"Unsupported execution mode: {mode}")

    # Final check for the output file existence (relevant for both modes)
    if not actual_wav_path.exists() or not actual_wav_path.is_file():
        raise FileNotFoundError(
            f"Generated .wav file not found at final path: {actual_wav_path}. "
            f"Mode: {mode}."
        )

    logger.info(f"Successfully produced WAV file: {actual_wav_path}")
    return actual_wav_path


if __name__ == "__main__":
    import json  # Added for dummy recipe_json_str

    logging.basicConfig(level=logging.DEBUG)
    logger.info("Testing exec_env.py with LocalPythonExecutor logic...")

    # Ensure settings are minimally available for paths
    if not hasattr(settings, "DEFAULT_OUT_DIR"):

        class DummySettings:
            DEFAULT_OUT_DIR = Path("./temp_output_exec_env_test")
            EXECUTION_MODE = "local_executor"  # Default to new mode for test
            COMPILER_TIMEOUT_S = 10  # For inline mode if tested

        settings = DummySettings()  # type: ignore
        settings.DEFAULT_OUT_DIR.mkdir(parents=True, exist_ok=True)

    # Test code for LocalPythonExecutor: must return (array, sr)
    sample_code_local_executor = """
import numpy as np
# soundfile is not needed by the *executed* code if it returns array

sr = 44100
duration = 1.0
frequency = 440.0
amplitude = 0.5

t = np.linspace(0, duration, int(sr * duration), endpoint=False)
wave = amplitude * np.sin(2 * np.pi * frequency * t)
# Crucially, return the array and sample rate
(wave, sr)
"""
    # Note: The last expression is returned by LocalPythonExecutor.
    # So, `(wave, sr)` as the last line works. `return (wave, sr)` would also work if inside a function.

    test_output_filename_local = "test_sine_local_executor.wav"
    try:
        logger.info("\n--- Testing 'local_executor' mode ---")
        dummy_recipe_json_local = json.dumps(
            {
                "effect_name": "test_sine_local",
                "duration": 1.0,
                "description": "Test sine wave generation",
            }
        )
        generated_wav_local = run_code(
            sample_code_local_executor,
            output_filename=test_output_filename_local,
            recipe_description="Test sine wave generation",
            recipe_duration=1.0,
            recipe_json_str=dummy_recipe_json_local,  # Added
            mode="local_executor",
        )
        logger.info(f"'local_executor' mode generated: {generated_wav_local}")
        assert generated_wav_local.exists()
        assert generated_wav_local.stat().st_size > 0
        logger.info(f"File size: {generated_wav_local.stat().st_size} bytes. OK.")
        # Manual cleanup needed for file in settings.DEFAULT_OUT_DIR / "exec_env_output"
    except Exception as e:
        logger.error(f"Error in 'local_executor' mode test: {e}", exc_info=True)

    # Test code for legacy "inline" mode: writes file itself
    sample_code_inline_legacy = """
import numpy as np
import soundfile as sf
from pathlib import Path

# OUTPUT_WAV_PATH is injected into the local scope by run_code for inline mode
sr = 44100
duration = 0.5
frequency = 220.0
amplitude = 0.3
t = np.linspace(0, duration, int(sr * duration), endpoint=False)
wave = amplitude * np.sin(2 * np.pi * frequency * t)
output_path = Path(OUTPUT_WAV_PATH)
output_path.parent.mkdir(parents=True, exist_ok=True)
sf.write(output_path, wave, sr, subtype='FLOAT')
"""
    test_output_filename_inline = "test_sine_inline_legacy.wav"
    try:
        logger.info("\n--- Testing 'inline' mode (legacy) ---")
        dummy_recipe_json_inline = json.dumps(
            {
                "effect_name": "test_sine_inline",
                "duration": 0.5,
                "description": "Test inline sine wave generation",
            }
        )
        generated_wav_inline = run_code(
            sample_code_inline_legacy,
            output_filename=test_output_filename_inline,
            recipe_description="Test inline sine wave generation",
            recipe_duration=0.5,
            recipe_json_str=dummy_recipe_json_inline,  # Added
            mode="inline",
        )
        logger.info(f"'inline' mode generated: {generated_wav_inline}")
        assert generated_wav_inline.exists()
        assert generated_wav_inline.stat().st_size > 0
        logger.info(f"File size: {generated_wav_inline.stat().st_size} bytes. OK.")
    except Exception as e:
        logger.error(f"Error in 'inline' mode test: {e}", exc_info=True)

    print(
        f"\nFinished exec_env.py tests. Please check {settings.DEFAULT_OUT_DIR / 'exec_env_output'} for generated files and clean up manually."
    )
