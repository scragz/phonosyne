"""
Execution Environment for Dynamically Generated Code

This module provides a secure environment for executing Python code generated by Phonosyne agents
using smolagents.LocalPythonExecutor to analyze AST and restrict operations/imports.
It also includes functionality to run SuperCollider code, now with an OSC-based control model.

Key features:
- `run_python_code` function to execute a string of Python code (if you have one).
- `run_supercollider_code` function to:
    - Start `scsynth` (SuperCollider server).
    - Start `sclang` with a user-provided script that defines SynthDefs and OSC handlers.
      (This script should not exit itself).
    - Control `sclang` via OSC messages from Python to manage synthesis and recording.
    - Terminate `sclang` and `scsynth`.
- Authorizes specific imports for Python code execution.

@dependencies
- `smolagents.local_python_executor.LocalPythonExecutor` (for Python execution)
- `python-osc` (for SuperCollider OSC communication)
- `numpy`, `soundfile`, `pathlib`, `typing`, `logging`, `phonosyne.settings`

@notes
- For `run_supercollider_code`, the provided SC `code` must be designed for OSC control.
"""

import logging
import os
import select
import subprocess
import time
from pathlib import Path

from phonosyne import settings

# Attempt to import python-osc
try:
    from pythonosc import osc_message_builder, udp_client

    PYTHONOSC_AVAILABLE = True
except ImportError:
    PYTHONOSC_AVAILABLE = False

logger = logging.getLogger(__name__)

SCLANG_READY_SIGNAL = "Phonosyne SuperCollider script ready"


class CodeExecutionError(Exception):
    """Custom exception for errors during code execution or processing."""

    pass


class SecurityException(CodeExecutionError):  # Keep for compatibility if used elsewhere
    """Custom exception for security-related issues."""

    pass


def run_supercollider_code(
    code: str,
    output_filename: str,
    duration: float = 15.0,
    effect_name: str | None = None,
    sclang_executable_path: str = "sclang",
    scsynth_executable_path: str = "scsynth",
    sclang_osc_host: str = "127.0.0.1",
    sclang_osc_port: int = 57120,
    scsynth_udp_port: int = 57110,
) -> Path:
    """
    Executes SuperCollider code by booting scsynth, then running an sclang script
    to define SynthDefs and OSC handlers. Python then communicates with sclang via OSC
    to trigger synthesis and recording.

    Args:
        code: SuperCollider script string. This script should define SynthDefs,
              OSC handlers (e.g., for /phonosyne/render, /phonosyne/stop),
              and should NOT call 0.exit itself. It relies on Python for control.
        output_filename: Absolute path for the output .wav file.
        duration: Target duration in seconds for the audio.
        effect_name: Optional name for the effect.
        sclang_executable_path: Path to the sclang executable.
        scsynth_executable_path: Path to the scsynth executable.
        sclang_osc_host: Host for sclang's OSC server.
        sclang_osc_port: Port for sclang's OSC server.
        scsynth_udp_port: UDP port scsynth listens on.

    Returns:
        Path to the generated .wav file.

    Raises:
        CodeExecutionError: If execution fails, executables are not found,
                            OSC communication fails, or output file isn't created.
        ImportError: If python-osc is not installed.
    """
    if not PYTHONOSC_AVAILABLE:
        raise ImportError(
            "The python-osc library is required for OSC communication with SuperCollider. "
            "Please install it (e.g., pip install python-osc)."
        )

    logger.info(
        f"Initiating SuperCollider OSC-controlled execution for: '{output_filename}'"
    )
    logger.debug(f"Target duration: {duration}s, Effect name: {effect_name}")
    logger.debug(
        f"sclang: {sclang_executable_path}, scsynth: {scsynth_executable_path}"
    )
    logger.debug(
        f"sclang OSC: {sclang_osc_host}:{sclang_osc_port}, scsynth UDP: {scsynth_udp_port}"
    )

    actual_wav_path = Path(output_filename)
    if not actual_wav_path.is_absolute():
        err_msg = f"output_filename '{output_filename}' must be an absolute path."
        logger.error(err_msg)
        raise CodeExecutionError(err_msg)

    try:
        actual_wav_path.parent.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        raise CodeExecutionError(
            f"Could not create parent directory {actual_wav_path.parent}: {e}"
        ) from e

    scsynth_proc = None
    sclang_proc = None

    safe_duration = duration if duration > 0 else 15.0
    # Increased buffer for OSC model: setup time, OSC comms, file writing buffer
    operation_buffer_seconds = getattr(settings, "SCLANG_TIMEOUT_BUFFER_SECONDS", 30.0)
    overall_timeout_seconds = safe_duration + operation_buffer_seconds
    operation_start_time = time.monotonic()

    error_keywords_lower = [
        "error:",
        "failure in server",
        "doesnotunderstanderror",
        "exception:",
        "failed.",
        "syntax error",
        "parse failed",
        "segmentation fault",
        "illegal instruction",
        "address already in use",  # For server boot issues
        "server failed to start",  # Explicit scsynth failure
    ]
    scsynth_ready_signals = [
        "SuperCollider 3 server ready",
        "UDP server listening",
        "TCP server listening",  # If TCP is ever enabled by default or options
        "server ready",  # A more generic one
    ]

    try:
        # 1. Start scsynth (SuperCollider Server)
        logger.info(f"Starting scsynth (UDP port: {scsynth_udp_port})...")
        scsynth_cmd = [scsynth_executable_path, "-u", str(scsynth_udp_port)]
        try:
            scsynth_proc = subprocess.Popen(
                scsynth_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,  # Use text mode for easier parsing
                encoding="utf-8",
                errors="replace",
                bufsize=1,  # Line buffered
            )
        except FileNotFoundError:
            raise CodeExecutionError(
                f"scsynth executable not found at '{scsynth_executable_path}'. Is it in PATH?"
            )

        logger.info("Monitoring scsynth startup...")
        scsynth_boot_timeout_seconds = getattr(
            settings, "SCSYNTH_BOOT_TIMEOUT_SECONDS", 10.0
        )
        scsynth_boot_deadline = time.monotonic() + scsynth_boot_timeout_seconds
        scsynth_ready = False
        scsynth_startup_stdout = []
        scsynth_startup_stderr = []
        sclang_stdout_acc = []
        sclang_stderr_acc = []
        sclang_setup_error_message = None

        os.set_blocking(scsynth_proc.stdout.fileno(), False)
        os.set_blocking(scsynth_proc.stderr.fileno(), False)

        while time.monotonic() < scsynth_boot_deadline:
            if scsynth_proc.poll() is not None:
                # scsynth exited prematurely, collect output and break
                break

            ready_to_read, _, _ = select.select(
                [scsynth_proc.stdout, scsynth_proc.stderr], [], [], 0.1
            )
            for stream in ready_to_read:
                is_stdout = stream == scsynth_proc.stdout
                try:
                    for line in iter(stream.readline, ""):
                        if not line:
                            break
                        line_str = line.strip()
                        if not line_str:
                            continue

                        if is_stdout:
                            scsynth_startup_stdout.append(line_str)
                            logger.debug(f"scsynth STDOUT (boot): {line_str}")
                            for ready_signal in scsynth_ready_signals:
                                if ready_signal in line_str:
                                    scsynth_ready = True
                                    logger.info(
                                        f"scsynth ready signal detected: '{line_str}'"
                                    )
                                    break
                        else:  # stderr
                            scsynth_startup_stderr.append(line_str)
                            logger.warning(f"scsynth STDERR (boot): {line_str}")
                            # Check for critical errors in stderr as well
                            for err_kw in error_keywords_lower:
                                if err_kw in line_str.lower():
                                    # This is a critical error, scsynth likely won't become ready
                                    logger.error(
                                        f"Critical error keyword '{err_kw}' in scsynth stderr during boot: {line_str}"
                                    )
                                    # We could choose to break early here if error is fatal
                                    break
                        if scsynth_ready:
                            break
                    if scsynth_ready:
                        break
                except BlockingIOError:
                    pass
                except Exception as e_read_scsynth:
                    logger.warning(
                        f"Exception reading from scsynth during boot: {e_read_scsynth}"
                    )
                    # Potentially break or handle as a failure
                    break
            if scsynth_ready or scsynth_proc.poll() is not None:
                break

        # After loop, check status
        final_scsynth_stdout = "\\n".join(scsynth_startup_stdout)
        final_scsynth_stderr = "\\n".join(scsynth_startup_stderr)

        if not scsynth_ready and scsynth_proc.poll() is None:  # Timed out
            scsynth_proc.terminate()
            try:
                s_out, s_err = scsynth_proc.communicate(timeout=2)
                final_scsynth_stdout += ("\\n" + s_out) if s_out else ""
                final_scsynth_stderr += ("\\n" + s_err) if s_err else ""
            except subprocess.TimeoutExpired:
                scsynth_proc.kill()
                s_out, s_err = scsynth_proc.communicate(timeout=2)
                final_scsynth_stdout += ("\\n" + s_out) if s_out else ""
                final_scsynth_stderr += ("\\n" + s_err) if s_err else ""

            raise CodeExecutionError(
                f"scsynth timed out after {scsynth_boot_timeout_seconds}s. No ready signal detected.\\n"
                f"scsynth STDOUT: {final_scsynth_stdout.strip()}\\nscsynth STDERR: {final_scsynth_stderr.strip()}"
            )

        if (
            scsynth_proc.poll() is not None and not scsynth_ready
        ):  # Exited prematurely without being ready
            # Ensure all output is read if communicate wasn't called yet
            if (
                not final_scsynth_stdout and not final_scsynth_stderr
            ):  # if buffers are empty, try communicate
                s_out, s_err = scsynth_proc.communicate(
                    timeout=2
                )  # Already exited, so communicate should be fast
                final_scsynth_stdout = s_out or ""
                final_scsynth_stderr = s_err or ""

            raise CodeExecutionError(
                f"scsynth failed to start or exited prematurely. Exit code: {scsynth_proc.returncode}.\\n"
                f"scsynth STDOUT: {final_scsynth_stdout.strip()}\\nscsynth STDERR: {final_scsynth_stderr.strip()}"
            )

        logger.info("scsynth started successfully and is presumed ready.")

        # 2. Start sclang and send the script via stdin
        logger.info("Preparing to start sclang and send script via stdin.")
        logger.info(
            f"sclang should listen for OSC on {sclang_osc_host}:{sclang_osc_port}"
        )

        # The SC 'code' must be adapted for this OSC model.
        # It should NOT boot its own server or call 0.exit.
        # It should define OSCdefs listening on sclang_osc_port.
        # If sclang_osc_port is not the default 57120, the SC code *must* set NetAddr.langPort.
        # We could prepend this, but it's better if the user's script is aware.
        # For now, assume user's script handles its listening port or uses default 57120.

        script_content_preview_lines = code.splitlines()[:10]
        script_content_preview = "\\n".join(script_content_preview_lines)
        logger.debug(
            f"Preview of SC script content (up to 10 lines):\\n{script_content_preview.strip()}"
        )

        sclang_cmd = [sclang_executable_path]  # No script file argument
        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"  # Ensure consistent encoding for sclang
        env["LC_ALL"] = "en_US.UTF-8"

        logger.info(f"Executing sclang command: {' '.join(sclang_cmd)}")
        try:
            sclang_proc = subprocess.Popen(
                sclang_cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,  # Use text mode (universal_newlines=True)
                encoding="utf-8",  # Specify encoding
                errors="replace",  # Handle potential decoding errors
                bufsize=1,  # Line buffered
                env=env,
                start_new_session=True,  # Ensure sclang runs in its own session
            )
            logger.info(f"sclang started with PID: {sclang_proc.pid}")

            # Send the SuperCollider code to sclang's stdin
            if sclang_proc.stdin:
                logger.debug(
                    "Preparing SC server configuration and user script for stdin..."
                )

                # Part 1: Send server configuration code and execute it
                server_config_sc_code = (
                    f"Server.default.options.maxLogins = 4; // Allow multiple clients, good practice\n"
                    f'Server.default = Server("localhost", NetAddr("127.0.0.1", {scsynth_udp_port}));\n'
                    f'("SC_PYTHON_INJECT: Server.default configured to 127.0.0.1:" ++ {scsynth_udp_port}).postln;\n'
                    "\n\u000c\n"  # Execute this block
                )
                logger.debug("Writing SC server configuration to sclang stdin...")
                sclang_proc.stdin.write(server_config_sc_code)
                sclang_proc.stdin.flush()
                logger.debug("SC server configuration written and flushed.")

                # Brief pause for sclang to process the server configuration.
                time.sleep(0.5)  # May need adjustment

                # Part 2: Send the user's actual script (variable 'code'), wrapped in .interpret
                logger.debug("Preparing user's SC script for '.interpret' execution...")

                # Replace placeholders if they exist in the input 'code' string
                # This is particularly for test scripts like test.sc that use these placeholders.
                # LLM-generated code should ideally embed these values directly.
                code_to_process = code

                # More verbose logging for debugging placeholder replacement
                path_placeholder = "PYTHON_OUTPUT_PATH_PLACEHOLDER"
                duration_placeholder = "PYTHON_RECIPE_DURATION_PLACEHOLDER"
                effect_name_placeholder = "PYTHON_EFFECT_NAME_PLACEHOLDER"

                logger.debug(
                    f"Checking for placeholders in code_to_process (first 500 chars): {code_to_process[:500]}"
                )

                path_found = path_placeholder in code_to_process
                duration_found = duration_placeholder in code_to_process
                effect_name_found = effect_name_placeholder in code_to_process
                logger.debug(f"Placeholder '{path_placeholder}' found: {path_found}")
                logger.debug(
                    f"Placeholder '{duration_placeholder}' found: {duration_found}"
                )
                logger.debug(
                    f"Placeholder '{effect_name_placeholder}' found: {effect_name_found}"
                )

                if path_found:
                    sc_compatible_path = (
                        actual_wav_path.as_posix()
                    )  # SC uses forward slashes
                    code_to_process = code_to_process.replace(
                        path_placeholder, sc_compatible_path
                    )
                    logger.info(  # Changed to INFO for better visibility during testing
                        f"Replaced '{path_placeholder}' with: {sc_compatible_path}"
                    )

                if duration_found:
                    code_to_process = code_to_process.replace(
                        duration_placeholder, str(safe_duration)
                    )
                    logger.info(  # Changed to INFO
                        f"Replaced '{duration_placeholder}' with: {safe_duration}"
                    )

                if effect_name_found:
                    actual_effect_name = effect_name if effect_name else "UnnamedEffect"
                    code_to_process = code_to_process.replace(
                        effect_name_placeholder, actual_effect_name
                    )
                    logger.info(  # Changed to INFO
                        f"Replaced '{effect_name_placeholder}' with: {actual_effect_name}"
                    )

                # Log a preview of the script that will be escaped and interpreted
                processed_script_preview_lines = code_to_process.splitlines()[
                    :5
                ]  # Show first 5 lines
                processed_script_preview = "\\n".join(processed_script_preview_lines)
                logger.debug(
                    f"Preview of SC script to be interpreted (after potential placeholder replacement, up to 5 lines):\\n{processed_script_preview.strip()}"
                )

                escaped_user_code = (
                    code_to_process.replace("\\", "\\\\")
                    .replace('"', '\\"')
                    .replace("\n", "\\n")
                )
                user_script_to_interpret = f'"{escaped_user_code}".interpret;\n\u000c\n'

                logger.debug(
                    "Writing user's SC script (via .interpret) to sclang stdin..."
                )
                sclang_proc.stdin.write(user_script_to_interpret)
                sclang_proc.stdin.flush()
                logger.debug("User's SC script (via .interpret) written and flushed.")
            else:
                raise CodeExecutionError("sclang process stdin is not available.")

            # Initial check for immediate sclang errors or exit after sending both parts.
            # The previous sleep(1.0) was after the combined send. Now it's effectively after the second send.
            # Let's keep a similar delay here to check for early exit.
            time.sleep(0.75)  # Adjusted from 1.0, as 0.5 was already used mid-way.
            if sclang_proc.poll() is not None:  # sclang has already exited
                sclang_initial_stdout, sclang_initial_stderr = sclang_proc.communicate(
                    timeout=5
                )
                raise CodeExecutionError(
                    f"sclang failed to start or exited prematurely immediately after script submission (using .interpret). Exit code: {sclang_proc.returncode}.\\n"
                    f"Initial sclang STDOUT: {sclang_initial_stdout}\\n"
                    f"Initial sclang STDERR: {sclang_initial_stderr}"
                )
            logger.info(
                "sclang process started, script submitted via .interpret, and did not exit immediately. Proceeding to monitor for ready signal."
            )

        except FileNotFoundError:
            raise CodeExecutionError(
                f"sclang executable not found at '{sclang_executable_path}'. Is it in PATH?"
            )
        except (
            subprocess.TimeoutExpired
        ):  # This might be hit if communicate() above times out
            # Check if sclang_proc exists and has output before raising generic timeout
            sclang_out, sclang_err = "", ""
            if sclang_proc and sclang_proc.poll() is not None:  # if it exited
                sclang_out, sclang_err = sclang_proc.communicate(
                    timeout=2
                )  # try to get output
            raise CodeExecutionError(
                f"Timeout during initial communication with sclang after script submission (using .interpret).\\n"
                f"sclang STDOUT: {sclang_out}\\nsclang STDERR: {sclang_err}"
            )
        except (
            Exception
        ) as e_popen_or_write:  # Catch other exceptions during Popen or initial write
            raise CodeExecutionError(
                f"Error during sclang Popen or initial script write (using .interpret): {e_popen_or_write}"
            )

        os.set_blocking(sclang_proc.stdout.fileno(), False)
        os.set_blocking(sclang_proc.stderr.fileno(), False)

        sclang_setup_deadline = time.monotonic() + settings.SCLANG_SETUP_TIMEOUT_SECONDS

        logger.info("Monitoring sclang setup script output (text mode)...")
        initial_setup_phase_done = False

        while time.monotonic() < sclang_setup_deadline:
            if sclang_proc.poll() is not None:
                sclang_setup_error_message = (
                    "sclang process terminated prematurely during setup "
                    f"(exit code {sclang_proc.returncode})."
                )
                logger.error(sclang_setup_error_message)
                break

            ready_to_read, _, _ = select.select(
                [sclang_proc.stdout, sclang_proc.stderr], [], [], 0.1
            )
            for stream in ready_to_read:
                is_stdout = stream == sclang_proc.stdout
                try:
                    # Read available lines in text mode
                    for line in iter(stream.readline, ""):  # Read line by line
                        if (
                            not line
                        ):  # Empty string can mean EOF or just no more lines now
                            break

                        line_str = line.strip()
                        if not line_str:
                            continue

                        current_buffer_acc = (
                            sclang_stdout_acc if is_stdout else sclang_stderr_acc
                        )
                        current_buffer_acc.append(line_str)

                        log_level = logging.INFO if is_stdout else logging.WARNING
                        logger.log(
                            log_level,
                            f"sclang {'STDOUT' if is_stdout else 'STDERR'} (setup): {line_str}",
                        )

                        if is_stdout and SCLANG_READY_SIGNAL in line_str:
                            logger.info(
                                f"Detected sclang ready signal: '{SCLANG_READY_SIGNAL}'"
                            )
                            initial_setup_phase_done = True
                            # No need to break inner loop, consume all current output

                        for keyword in error_keywords_lower:
                            if keyword in line_str.lower():
                                sclang_setup_error_message = f"Error keyword '{keyword}' in sclang output: {line_str}"
                                logger.error(sclang_setup_error_message)
                                break
                        if sclang_setup_error_message:
                            break

                except BlockingIOError:
                    pass  # Expected with non-blocking reads if readline has nothing.
                except Exception as e_read:
                    logger.warning(
                        f"Exception reading from sclang during setup: {e_read}"
                    )
                    sclang_setup_error_message = f"Read exception: {e_read}"
                    break
            if sclang_setup_error_message or initial_setup_phase_done:
                break

        if (
            not initial_setup_phase_done and not sclang_setup_error_message
        ):  # Check if loop finished due to timeout
            if time.monotonic() >= sclang_setup_deadline:
                sclang_setup_error_message = f"sclang setup timed out after {settings.SCLANG_SETUP_TIMEOUT_SECONDS:.1f}s waiting for ready signal."
                logger.error(sclang_setup_error_message)

        if (
            sclang_setup_error_message
        ):  # Error during setup or premature exit or timeout
            # Try to capture any final output
            # communicate() is better for final capture with text=True
            sclang_final_stdout_communicate, sclang_final_stderr_communicate = "", ""
            if (
                sclang_proc.poll() is None
            ):  # if still running, try to get output before terminating
                try:
                    sclang_proc.terminate()  # Ask it to terminate
                    sclang_final_stdout_communicate, sclang_final_stderr_communicate = (
                        sclang_proc.communicate(timeout=2)
                    )
                except subprocess.TimeoutExpired:
                    sclang_proc.kill()
                    sclang_final_stdout_communicate, sclang_final_stderr_communicate = (
                        sclang_proc.communicate(timeout=2)
                    )  # get output after kill
            else:  # already terminated
                sclang_final_stdout_communicate, sclang_final_stderr_communicate = (
                    sclang_proc.communicate(timeout=2)
                )

            full_stdout = (
                "\\n".join(sclang_stdout_acc)
                + "\\n"
                + (sclang_final_stdout_communicate or "")
            )
            full_stderr = (
                "\\n".join(sclang_stderr_acc)
                + "\\n"
                + (sclang_final_stderr_communicate or "")
            )

            raise CodeExecutionError(
                f"Failed to set up sclang script: {sclang_setup_error_message}\\n"
                f"sclang STDOUT: {full_stdout.strip()}\\n"
                f"sclang STDERR: {full_stderr.strip()}"
            )

        if (
            not initial_setup_phase_done and time.monotonic() >= sclang_setup_deadline
        ):  # Timed out waiting for setup
            sclang_final_stdout_communicate, sclang_final_stderr_communicate = (
                sclang_proc.communicate(timeout=5)
            )
            full_stdout = (
                "\\n".join(sclang_stdout_acc)
                + "\\n"
                + (sclang_final_stdout_communicate or "")
            )
            full_stderr = (
                "\\n".join(sclang_stderr_acc)
                + "\\n"
                + (sclang_final_stderr_communicate or "")
            )
            raise CodeExecutionError(
                f"sclang setup script timed out after {settings.SCLANG_SETUP_TIMEOUT_SECONDS:.1f}s.\\n"
                f"sclang STDOUT: {full_stdout.strip()}\\n"
                f"sclang STDERR: {full_stderr.strip()}"
            )

        logger.info("sclang setup script processed. Proceeding with OSC control.")

        # 3. Python OSC Interaction with sclang
        osc_client = udp_client.UDPClient(sclang_osc_host, sclang_osc_port)

        # SC script needs OSCdefs for these paths, e.g.:
        # OSCdef(\\render, { |msg| var path=msg[1], dur=msg[2], effect=msg[3]; /* record logic */ }, '/phonosyne/render');
        # OSCdef(\\stop, { /* stop recording, free synth */ }, '/phonosyne/stop');

        logger.info(
            f"Sending /phonosyne/render OSC message to sclang ({sclang_osc_host}:{sclang_osc_port})"
        )
        render_msg_builder = osc_message_builder.OscMessageBuilder(
            address="/phonosyne/render"
        )
        render_msg_builder.add_arg(str(actual_wav_path))
        render_msg_builder.add_arg(safe_duration)
        # The SC script OSCdef for /phonosyne/render expects: path (string), duration (float)
        # The effect_name was removed from the SC script's OSCdef for /phonosyne/render
        # render_msg_builder.add_string(effect_name if effect_name else "unknown_effect")
        osc_client.send(render_msg_builder.build())

        logger.info(
            f"Waiting for recipe duration ({safe_duration}s) while sclang/scsynth operate..."
        )

        # Monitor sclang output and overall timeout during recipe duration
        recipe_end_time = time.monotonic() + safe_duration
        timed_out_during_recipe = False

        while time.monotonic() < recipe_end_time:
            if (time.monotonic() - operation_start_time) > overall_timeout_seconds:
                logger.error(
                    "Overall operation timeout reached during recipe execution."
                )
                timed_out_during_recipe = True
                break
            if sclang_proc.poll() is not None:
                logger.error(
                    f"sclang process terminated unexpectedly during recipe execution (exit code {sclang_proc.returncode})."
                )
                sclang_final_stdout_recipe, sclang_final_stderr_recipe = (
                    sclang_proc.communicate(timeout=5)
                )
                full_stdout_recipe = (
                    "\\n".join(sclang_stdout_acc)
                    + "\\n"
                    + (sclang_final_stdout_recipe or "")
                )
                full_stderr_recipe = (
                    "\\n".join(sclang_stderr_acc)
                    + "\\n"
                    + (sclang_final_stderr_recipe or "")
                )
                raise CodeExecutionError(
                    f"sclang exited prematurely during recipe.\\nSTDOUT: {full_stdout_recipe.strip()}\\nSTDERR: {full_stderr_recipe.strip()}"
                )

            ready_to_read, _, _ = select.select(
                [sclang_proc.stdout, sclang_proc.stderr], [], [], 0.2
            )
            for stream in ready_to_read:
                try:
                    for line in iter(stream.readline, ""):  # Read line by line
                        if not line:
                            break
                        line_str = line.strip()
                        if line_str:
                            is_stdout = stream == sclang_proc.stdout
                            current_buffer_acc = (
                                sclang_stdout_acc if is_stdout else sclang_stderr_acc
                            )
                            current_buffer_acc.append(line_str)
                            logger.info(
                                f"sclang {'STDOUT' if is_stdout else 'STDERR'} (recipe): {line_str}"
                            )
                except BlockingIOError:
                    pass
                except Exception as e_read_recipe:
                    logger.warning(
                        f"Exception reading from sclang during recipe: {e_read_recipe}"
                    )

        if timed_out_during_recipe:
            raise CodeExecutionError(
                "Overall operation timeout during recipe execution."
            )

        logger.info(
            f"Recipe duration elapsed. Sending /phonosyne/stop OSC message to sclang ({sclang_osc_host}:{sclang_osc_port})"
        )
        stop_msg_builder = osc_message_builder.OscMessageBuilder(
            address="/phonosyne/stop"
        )
        osc_client.send(stop_msg_builder.build())

        # Wait a moment for sclang to process the stop message and finish writing file
        stop_processing_time = getattr(
            settings, "SCLANG_STOP_PROCESSING_TIME_SECONDS", 5.0
        )
        logger.info(
            f"Waiting {stop_processing_time}s for sclang to process stop and finalize recording..."
        )

        stop_wait_start_time = time.monotonic()
        while time.monotonic() < stop_wait_start_time + stop_processing_time:
            if sclang_proc.poll() is not None:
                logger.warning(
                    f"sclang process terminated during stop processing time (exit code {sclang_proc.returncode})."
                )
                break  # sclang already exited, no need to wait further

            # Drain any remaining output from sclang during this wait
            ready_to_read, _, _ = select.select(
                [sclang_proc.stdout, sclang_proc.stderr], [], [], 0.1
            )
            for stream in ready_to_read:
                try:
                    for line in iter(stream.readline, ""):  # Read line by line
                        if not line:
                            break
                        line_str = line.strip()
                        if line_str:
                            is_stdout = stream == sclang_proc.stdout
                            current_buffer_acc = (
                                sclang_stdout_acc if is_stdout else sclang_stderr_acc
                            )
                            current_buffer_acc.append(line_str)
                            logger.log(
                                logging.INFO if is_stdout else logging.WARNING,
                                f"sclang {'STDOUT' if is_stdout else 'STDERR'} (post-stop): {line_str}",
                            )
                except BlockingIOError:
                    pass
                except Exception as e_drain:
                    logger.warning(
                        f"Exception draining sclang output post-stop: {e_drain}"
                    )
                    break  # Stop trying to drain if error

            time.sleep(0.1)  # Brief sleep to avoid busy-waiting if no output

        logger.info("Finished waiting for sclang stop processing.")

    except osc_message_builder.BuildError as e_osc_build:
        raise CodeExecutionError(
            f"Failed to build OSC message: {e_osc_build}"
        ) from e_osc_build
    except Exception as e_general:
        # Ensure processes are cleaned up if an unexpected error occurs mid-flight
        if sclang_proc and sclang_proc.poll() is None:
            logger.warning(f"Terminating sclang due to exception: {e_general}")
            sclang_proc.terminate()
            try:
                sclang_proc.wait(timeout=5)
            except subprocess.TimeoutExpired:
                logger.warning("sclang did not terminate gracefully, killing.")
                sclang_proc.kill()
        if scsynth_proc and scsynth_proc.poll() is None:
            logger.warning(f"Terminating scsynth due to exception: {e_general}")
            scsynth_proc.terminate()
            try:
                scsynth_proc.wait(timeout=5)
            except subprocess.TimeoutExpired:
                logger.warning("scsynth did not terminate gracefully, killing.")
                scsynth_proc.kill()
        raise CodeExecutionError(
            f"An unexpected error occurred: {e_general}"
        ) from e_general

    finally:
        logger.info("Cleaning up SuperCollider processes (OSC model)...")

        # Terminate sclang first
        if sclang_proc and sclang_proc.poll() is None:
            logger.info(f"Terminating sclang process (PID: {sclang_proc.pid})...")
            sclang_proc.terminate()
            try:
                sclang_proc.wait(timeout=settings.SCLANG_TERMINATE_TIMEOUT_SECONDS)
                logger.info(f"sclang process (PID: {sclang_proc.pid}) terminated.")
            except subprocess.TimeoutExpired:
                logger.warning(
                    f"sclang process (PID: {sclang_proc.pid}) did not terminate gracefully, killing."
                )
                sclang_proc.kill()
                try:
                    sclang_proc.wait(timeout=settings.SCLANG_KILL_TIMEOUT_SECONDS)
                    logger.info(f"sclang process (PID: {sclang_proc.pid}) killed.")
                except subprocess.TimeoutExpired:
                    logger.error(
                        f"sclang process (PID: {sclang_proc.pid}) failed to die even after kill."
                    )
        elif sclang_proc:
            logger.info(
                f"sclang process (PID: {sclang_proc.pid}) already terminated with code: {sclang_proc.returncode}."
            )

        # Capture any final output from sclang
        if sclang_proc:
            for stream_obj, acc_list, stream_name in [
                (sclang_proc.stdout, sclang_stdout_acc, "stdout"),
                (sclang_proc.stderr, sclang_stderr_acc, "stderr"),
            ]:
                if stream_obj and not stream_obj.closed:
                    try:
                        content = stream_obj.read()
                        if content:  # content is a string
                            acc_list.append(content)  # Appending string
                    except Exception as e_read_final:
                        try:
                            # Attempt to log the error message as a string
                            logger.warning(
                                f"Error reading final sclang {stream_name}: {str(e_read_final)}"
                            )
                        except Exception as log_e:
                            # Fallback if even string conversion of error fails
                            logger.warning(
                                f"Error reading final sclang {stream_name}, and also failed to log original exception: {log_e}"
                            )

        sclang_final_stdout = (
            "\\n".join(sclang_stdout_acc).strip() if sclang_stdout_acc else ""
        )
        sclang_final_stderr = (
            "\\n".join(sclang_stderr_acc).strip() if sclang_stderr_acc else ""
        )

        if sclang_final_stdout:
            logger.debug(f"Final accumulated sclang STDOUT:\\n{sclang_final_stdout}")
        if sclang_final_stderr:
            logger.debug(f"Final accumulated sclang STDERR:\\n{sclang_final_stderr}")

        # Attempt to quit scsynth via OSC first, then terminate/kill process
        if scsynth_proc and scsynth_proc.poll() is None:
            if PYTHONOSC_AVAILABLE:
                logger.info(
                    f"Attempting to quit scsynth (PID: {scsynth_proc.pid}) via OSC message to port {scsynth_udp_port}..."
                )
                try:
                    # scsynth listens on its own UDP port for /quit
                    scsynth_osc_client = udp_client.UDPClient(
                        sclang_osc_host,
                        scsynth_udp_port,  # Assuming scsynth is on the same host
                    )
                    quit_msg = osc_message_builder.OscMessageBuilder(address="/quit")
                    scsynth_osc_client.send(quit_msg.build())
                    logger.info(
                        f"Sent /quit OSC to scsynth on port {scsynth_udp_port}."
                    )
                    # Give scsynth a moment to process the /quit message
                    time.sleep(
                        getattr(settings, "SCSYNTH_QUIT_GRACE_PERIOD_SECONDS", 0.5)
                    )
                except Exception as e_osc_quit:
                    logger.warning(
                        f"Failed to send /quit OSC message to scsynth: {e_osc_quit}"
                    )

            if scsynth_proc.poll() is None:  # Check if OSC quit worked
                logger.info(f"Terminating scsynth process (PID: {scsynth_proc.pid})...")
                scsynth_proc.terminate()
                try:
                    scsynth_proc.wait(
                        timeout=settings.SCSYNTH_TERMINATE_TIMEOUT_SECONDS
                    )
                    logger.info(
                        f"scsynth process (PID: {scsynth_proc.pid}) terminated."
                    )
                except subprocess.TimeoutExpired:
                    logger.warning(
                        f"scsynth process (PID: {scsynth_proc.pid}) did not terminate gracefully, killing."
                    )
                    scsynth_proc.kill()
                    try:
                        scsynth_proc.wait(timeout=settings.SCSYNTH_KILL_TIMEOUT_SECONDS)
                        logger.info(
                            f"scsynth process (PID: {scsynth_proc.pid}) killed."
                        )
                    except subprocess.TimeoutExpired:
                        logger.error(
                            f"scsynth process (PID: {scsynth_proc.pid}) failed to die even after kill."
                        )
        elif scsynth_proc:
            logger.info(
                f"scsynth process (PID: {scsynth_proc.pid}) already terminated with code: {scsynth_proc.returncode}."
            )

        # Capture any final output from scsynth
        scsynth_final_stdout_str = ""
        scsynth_final_stderr_str = ""
        if scsynth_proc:
            if scsynth_proc.stdout and not scsynth_proc.stdout.closed:
                try:
                    scsynth_final_stdout_str = scsynth_proc.stdout.read() or ""
                except Exception as e_read_scsynth_stdout_final:
                    logger.warning(
                        f"Error reading final scsynth stdout: {e_read_scsynth_stdout_final}"
                    )
            if scsynth_proc.stderr and not scsynth_proc.stderr.closed:
                try:
                    scsynth_final_stderr_str = scsynth_proc.stderr.read() or ""
                except Exception as e_read_scsynth_stderr_final:
                    logger.warning(
                        f"Error reading final scsynth stderr: {e_read_scsynth_stderr_final}"
                    )

        if scsynth_final_stdout_str:
            logger.debug(f"Final scsynth STDOUT:\\n{scsynth_final_stdout_str}")
        if scsynth_final_stderr_str:
            logger.debug(f"Final scsynth STDERR:\\n{scsynth_final_stderr_str}")

    # Final check for output file, using the potentially updated sclang_final_stdout/stderr
    if not actual_wav_path.exists() or not actual_wav_path.is_file():
        final_stdout_for_error = (
            sclang_final_stdout
            if sclang_final_stdout
            else "N/A (sclang STDOUT capture failed or empty)"
        )
        final_stderr_for_error = (
            sclang_final_stderr
            if sclang_final_stderr
            else "N/A (sclang STDERR capture failed or empty)"
        )

        raise CodeExecutionError(
            f"Output .wav file not found at {actual_wav_path} after OSC-controlled execution.\\n"
            f"Final sclang STDOUT:\\n{final_stdout_for_error}\\n"
            f"Final sclang STDERR:\\n{final_stderr_for_error}"
        )

    logger.info(
        f"Successfully produced WAV file via OSC-controlled SuperCollider: {actual_wav_path}"
    )
    return actual_wav_path


# If you have a run_python_code function, it would go here.
# For example:
# def run_python_code(code: str, output_filename: str, duration: float, effect_name: str | None = None) -> Path:
#     logger.warning("run_python_code is not fully implemented in this refactoring pass.")
#     # ... (original run_python_code logic if it exists and is separate) ...
#     raise NotImplementedError("run_python_code needs to be reviewed/reinstated if used.")
