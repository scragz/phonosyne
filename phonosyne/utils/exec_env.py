"""
Execution Environment for Dynamically Generated Code

This module provides a secure environment for executing Python code generated by Phonosyne agents
using smolagents.LocalPythonExecutor to analyze AST and restrict operations/imports.

Key features:
- `run_code` function to execute a string of Python code.
- Authorizes specific imports (numpy, scipy, soundfile, math, random).
- Expects the executed code to return a numpy array representing the audio data.
- Saves the returned audio data to a .wav file.

@dependencies
- `smolagents.local_python_executor.LocalPythonExecutor`
- `numpy` (for type hinting the expected array)
- `soundfile` (for writing the WAV file)
- `pathlib.Path`, `typing`, `logging`
- `phonosyne.settings`

@notes
- The generated code must return a numpy array representing the audio data.
- The sample rate is determined from settings.DEFAULT_SR.
"""

import array
import json
import logging
import math
import random
import shutil
from pathlib import Path
from typing import Any, Dict, Tuple

import numpy as np
import scipy  # Added
import soundfile as sf
from smolagents.local_python_executor import InterpreterError, LocalPythonExecutor

from phonosyne import settings

logger = logging.getLogger(__name__)

# <<< BEGIN MONKEY PATCH FOR scipy.sparse.coo.upcast >>>
# This patch is to support LLM-generated code that might still refer to
# scipy.sparse.coo.upcast, which has been removed from modern SciPy versions.
# We attempt to add it to the underlying scipy.sparse._coo module.
_monkey_patch_logger = logging.getLogger(__name__ + ".monkey_patch")

try:
    import scipy.sparse._coo as scipy_coo_module

    # numpy is imported as np above

    if not hasattr(scipy_coo_module, "upcast"):

        def _upcast_shim(*args):
            """
            Shim for the removed scipy.sparse.coo.upcast.
            Returns the nearest common type of a sequence of dtypes.
            Based on numpy.find_common_type.
            """
            dtype_objects = [np.dtype(arg) for arg in args]
            return np.find_common_type(dtype_objects, [])

        scipy_coo_module.upcast = _upcast_shim
        _monkey_patch_logger.info(
            "Successfully monkey-patched scipy.sparse._coo.upcast to restore functionality "
            "for LLM-generated code."
        )
    else:
        _monkey_patch_logger.info(
            "scipy.sparse._coo.upcast already exists. No monkey patch applied."
        )
except ImportError:
    _monkey_patch_logger.warning(
        "Could not import scipy.sparse._coo to attempt monkey-patching for upcast. "
        "If LLM-generated code relies on a patched scipy.sparse.coo.upcast, it may fail."
    )
except Exception as e:
    _monkey_patch_logger.error(
        f"An unexpected error occurred while trying to monkey-patch scipy.sparse._coo.upcast: {e}",
        exc_info=True,
    )
# <<< END MONKEY PATCH FOR scipy.sparse.coo.upcast >>>

# No restricted globals needed as we only use LocalPythonExecutor

# Authorized imports for LocalPythonExecutor
# Based on compiler.md: numpy, scipy.signal, soundfile as sf, plus random, math
# os, tempfile, time, json, sys are generally unsafe for LLM code.
# LocalPythonExecutor has its own defaults, we add to them or specify a full list.
# Common safe DSP modules:
AUTHORIZED_IMPORTS_FOR_DSP = [
    "numpy",
    "numpy.*",
    "scipy",
    "scipy.*",
    "math",
    "random",
    "array",
    "json",
    "phonosyne.dsp.effects",  # Allows generated code to 'import phonosyne.dsp.effects as fx' if ever needed for other reasons
    "phonosyne.dsp.effects.*",  # Allows generated code to 'from phonosyne.dsp.effects import some_utility' if ever needed
    "phonosyne.dsp.effects.feedback_network",  # Added for MFN
    "phonosyne.dsp.effects.feedback_network.*",  # Added for MFN utilities if any are exposed
    "phonosyne.settings",  # Added to allow generated scripts to import settings
]


class CodeExecutionError(Exception):
    """Custom exception for errors during code execution or processing."""

    pass


class SecurityException(CodeExecutionError):  # Keep for compatibility if used elsewhere
    """Custom exception for security-related issues."""

    pass


def run_code(
    code: str,
    output_filename: str,
    recipe_description: str = "",
    recipe_duration: float = 15.0,
    recipe_json_str: str = "",
) -> Path:
    """
    Executes Python code, saves the output as a .wav file, and returns its path.

    Uses LocalPythonExecutor to safely execute generated code and expects a numpy array as output.

    Args:
        code: The Python code string to execute.
        output_filename: Desired name for the output .wav file (e.g., "sample_01.wav").
        recipe_description: The natural language description for synthesis.
        recipe_duration: The target duration in seconds for the audio.
        recipe_json_str: Optional JSON string with recipe details.

    Returns:
        Path to the generated .wav file.

    Raises:
        CodeExecutionError: If code execution fails, output is invalid, or file saving fails.
    """
    logger.info(f"Executing code for target output: {output_filename}")

    # Determine the final directory for the output WAV.
    # exec_env_output is a persistent temporary holding place.
    # The orchestrator should move files from here to the final brief-specific output dir.
    persistent_temp_dir = settings.DEFAULT_OUT_DIR / "exec_env_output"
    # Ensure the path is absolute to avoid any resolution issues
    persistent_temp_dir = persistent_temp_dir.absolute()
    persistent_temp_dir.mkdir(parents=True, exist_ok=True)

    logger.info(f"Writing output to directory: {persistent_temp_dir}")

    # Extract just the filename without any path components
    # This ensures we don't accidentally create nested paths
    safe_filename = Path(output_filename).name
    if not safe_filename or safe_filename in (".", ".."):
        safe_filename = "default_dsp_output.wav"
        logger.warning(
            f"Original output_filename '{output_filename}' was invalid/empty, using '{safe_filename}'"
        )

    # Create a Path object for the final intended output
    actual_wav_path = persistent_temp_dir / safe_filename
    logger.info(f"Full output path will be: {actual_wav_path}")

    dsp_effect_tools = {}
    # List of effect names (module names) that should have an apply_<effect_name> function
    effects_to_load = [
        "autowah",
        "chorus",
        "compressor",
        "delay",
        "distortion",
        "dub_echo",
        "echo",
        "flanger",
        "fuzz",
        "long_reverb",
        "noise_gate",
        "overdrive",
        "particle",
        "phaser",
        "rainbow_machine",
        "short_reverb",
        "tremolo",
        "vibrato",
        "feedback_network",  # Added MFN so apply_mfn can be loaded as a tool
    ]

    for effect_module_name in effects_to_load:
        function_name = f"apply_{effect_module_name}"
        try:
            # Dynamically import the module and get the function
            module = __import__(
                f"phonosyne.dsp.effects.{effect_module_name}",
                fromlist=[function_name],
            )
            func = getattr(module, function_name)
            dsp_effect_tools[function_name] = func
        except ImportError as e:
            logger.error(
                f"Failed to import {function_name} from phonosyne.dsp.effects.{effect_module_name}: {e}"
            )
        except AttributeError as e:
            logger.error(
                f"Function {function_name} not found in phonosyne.dsp.effects.{effect_module_name}: {e}"
            )
        except Exception as e:
            logger.error(
                f"Unexpected error loading effect {effect_module_name} ({function_name}): {e}"
            )

    executor = LocalPythonExecutor(
        additional_authorized_imports=AUTHORIZED_IMPORTS_FOR_DSP
    )

    # Prepare modules to be sent as variables
    modules_as_variables = {
        "np": np,
        "numpy": np,  # Allow use of 'numpy.array' if AI generates that
        "scipy": scipy,
        "math": math,
        "random": random,
        "array": array,  # The array module
        "json": json,  # json module itself
        "settings": settings,  # Make the phonosyne.settings module available globally
    }

    # Prepare functions/callables to be sent as tools
    functions_as_tools = {
        "hash": hash,  # Built-in hash function
        # Add other specific, safe built-ins or utilities if needed
    }
    functions_as_tools.update(
        dsp_effect_tools
    )  # Add all dynamically loaded apply_... functions

    # Combine recipe-specific variables with modules for send_variables
    all_variables_to_send = {
        "output_filename": output_filename,
        "description": recipe_description,
        "duration": recipe_duration,
        "recipe_json": recipe_json_str,  # Make the JSON string available as 'recipe_json'
    }
    all_variables_to_send.update(modules_as_variables)

    executor.send_variables(all_variables_to_send)
    executor.send_tools(functions_as_tools)

    try:
        logger.debug(
            f"Attempting to execute code for {output_filename}:\\n---\\n{code}\\n---"
        )
        # LocalPythonExecutor.__call__ returns a 3-tuple: (output, logs, is_final_answer)
        # The 'output' (here, `code_output`) is what the LLM-generated code itself returns.
        code_output, logs, is_final_answer = executor(
            code
        )  # This is the actual execution call
        logger.debug(
            f"LocalPythonExecutor raw output (result of executed code) for {output_filename}: {code_output!r}"
        )
        logger.debug(f"LocalPythonExecutor logs for {output_filename}: {logs}")

        if (
            is_final_answer
        ):  # Phonosyne doesn't use final_answer concept from smolagents here
            logger.warning(
                "LocalPythonExecutor indicated final_answer, which is not expected in this context."
            )

        if code_output is None:
            raise CodeExecutionError(
                "Executed code returned None. "
                "Expected a (numpy.ndarray, int) tuple for (audio_data, sample_rate)."
            )

        audio_data: np.ndarray | None = None
        sample_rate: int | None = None

        # Primary expectation: (numpy.ndarray, int) tuple as per overview.md
        if isinstance(code_output, tuple) and len(code_output) == 2:
            potential_audio_data, potential_sample_rate = code_output
            if not isinstance(potential_audio_data, np.ndarray):
                raise CodeExecutionError(
                    "First element of the tuple returned by executed code is not a numpy.ndarray."
                    f" Got: {type(potential_audio_data)}"
                )
            if not isinstance(potential_sample_rate, int):
                raise CodeExecutionError(
                    "Second element of the tuple returned by executed code is not an int (sample_rate)."
                    f" Got: {type(potential_sample_rate)}"
                )
            audio_data = potential_audio_data
            sample_rate = potential_sample_rate
            logger.info(
                f"Executed code for {output_filename} returned (audio_data, sample_rate) tuple. "
                f"Audio data shape: {audio_data.shape}, Sample rate: {sample_rate} Hz."
            )
        elif isinstance(
            code_output, np.ndarray
        ):  # Fallback for legacy/incorrect direct ndarray return
            audio_data = code_output
            sample_rate = settings.DEFAULT_SR  # Use global default sample rate
            logger.warning(
                f"Executed code for {output_filename} returned a direct numpy.ndarray instead of the expected (audio_data, sample_rate) tuple. "
                f"Using default sample rate: {sample_rate} Hz. Audio data shape: {audio_data.shape}."
            )
        else:  # Neither None, nor tuple, nor ndarray
            raise CodeExecutionError(
                "Executed code did not return the expected (numpy.ndarray, int) tuple or a direct numpy.ndarray. "
                f"Got type: {type(code_output)}, Value: {code_output!r}"
            )

        # Ensure audio_data and sample_rate are valid before proceeding (should be caught above by checks)
        if (
            audio_data is None or sample_rate is None
        ):  # This should ideally not be reached if logic above is correct
            raise CodeExecutionError(
                "Internal error: audio_data or sample_rate not set after processing code output. This indicates a flaw in run_code's logic."
            )

        logger.info(
            f"Processed output for {output_filename}. Audio data shape: {audio_data.shape}, "
            f"Sample rate: {sample_rate} Hz."
        )
        # Save the returned audio data to the WAV file
        try:
            # Ensure directory exists
            actual_wav_path.parent.mkdir(parents=True, exist_ok=True)

            # Log more details for debugging
            logger.info(
                f"Saving audio data (shape: {audio_data.shape}) to {actual_wav_path} with sample rate {sample_rate}"
            )

            # Write the file
            sf.write(
                actual_wav_path, audio_data, sample_rate, subtype="FLOAT"
            )  # Defaulting to 32-bit float

            # Verify file was created
            if actual_wav_path.exists() and actual_wav_path.is_file():
                logger.info(
                    f"Audio data successfully saved to {actual_wav_path} (Size: {actual_wav_path.stat().st_size} bytes)"
                )
            else:
                # Check if the file might have been created in the system temp directory
                tmp_path = None
                if "/tmp/" in str(output_filename) or "/private/tmp/" in str(
                    output_filename
                ):
                    tmp_path = Path(output_filename)
                    if tmp_path.exists() and tmp_path.is_file():
                        logger.warning(
                            f"File was created in system temp directory: {tmp_path}"
                        )
                        try:
                            # Copy file from temp to the intended location
                            shutil.copy2(str(tmp_path), str(actual_wav_path))
                            logger.info(
                                f"Successfully copied from {tmp_path} to {actual_wav_path}"
                            )
                            # Update the path to be returned
                            tmp_path.unlink()
                            logger.info(f"Removed original temp file: {tmp_path}")
                        except Exception as copy_err:
                            logger.error(
                                f"Error copying from temp dir: {copy_err}",
                                exc_info=True,
                            )
                            raise FileNotFoundError(
                                f"Failed to copy temp file from {tmp_path} to {actual_wav_path}: {copy_err}"
                            )
                    else:
                        tmp_path = None

                if not tmp_path:
                    raise FileNotFoundError(
                        f"Failed to create WAV file at {actual_wav_path}"
                    )
        except Exception as e:
            logger.error(f"Error saving audio data to file: {e}", exc_info=True)
            raise CodeExecutionError(f"Failed to save WAV file: {e}") from e

    except InterpreterError as e:  # Specific error from LocalPythonExecutor
        logger.error(f"Error during code execution: {e}")
        raise CodeExecutionError(f"Execution failed: {e}") from e
    except Exception as e:  # Catch other errors like soundfile write issues
        logger.error(f"Error processing result from execution: {e}", exc_info=True)
        raise CodeExecutionError(f"Failed to process or save audio: {e}") from e

    # Final check for the output file existence
    if not actual_wav_path.exists() or not actual_wav_path.is_file():
        raise FileNotFoundError(
            f"Generated .wav file not found at final path: {actual_wav_path}."
        )

    logger.info(f"Successfully produced WAV file: {actual_wav_path}")
    return actual_wav_path


if __name__ == "__main__":
    import json

    logging.basicConfig(level=logging.DEBUG)
    logger.info("Testing exec_env.py...")

    # Ensure settings are minimally available for paths
    if not hasattr(settings, "DEFAULT_OUT_DIR"):

        class DummySettings:
            DEFAULT_OUT_DIR = Path("./temp_output_exec_env_test")
            DEFAULT_SR = 48000

        settings = DummySettings()  # type: ignore
        settings.DEFAULT_OUT_DIR.mkdir(parents=True, exist_ok=True)

    # Test code that returns a numpy array
    sample_code = """
import numpy as np
from phonosyne import settings

frequency = 440.0
amplitude = 0.5

# Use settings.DEFAULT_SR and duration from variables
t = np.linspace(0, duration, int(settings.DEFAULT_SR * duration), endpoint=False)
wave = amplitude * np.sin(2 * np.pi * frequency * t)

# Return the numpy array
wave
"""

    test_output_filename = "test_sine.wav"
    try:
        logger.info("\n--- Testing code execution ---")
        dummy_recipe_json = json.dumps(
            {
                "effect_name": "test_sine",
                "duration": 1.0,
                "description": "Test sine wave generation",
            }
        )

        generated_wav = run_code(
            sample_code,
            output_filename=test_output_filename,
            recipe_description="Test sine wave generation",
            recipe_duration=1.0,
            recipe_json_str=dummy_recipe_json,
        )

        logger.info(f"Generated audio file: {generated_wav}")
        assert generated_wav.exists()
        assert generated_wav.stat().st_size > 0
        logger.info(f"File size: {generated_wav.stat().st_size} bytes. Test passed.")
        # Manual cleanup needed for file in settings.DEFAULT_OUT_DIR / "exec_env_output"
    except Exception as e:
        logger.error(f"Error in execution test: {e}", exc_info=True)

    print(
        f"\nFinished exec_env.py tests. Please check {settings.DEFAULT_OUT_DIR / 'exec_env_output'} for generated files and clean up manually."
    )
