"""
Execution Environment for Dynamically Generated Code

This module provides a secure environment for executing Python code generated by Phonosyne agents
using smolagents.LocalPythonExecutor to analyze AST and restrict operations/imports.
It also includes functionality to run SuperCollider code, now with an OSC-based control model.

Key features:
- `run_python_code` function to execute a string of Python code (if you have one).
- `run_supercollider_code` function to:
    - Start `scsynth` (SuperCollider server).
    - Start `sclang` with a user-provided script that defines SynthDefs and OSC handlers.
      (This script should not exit itself).
    - Control `sclang` via OSC messages from Python to manage synthesis and recording.
    - Terminate `sclang` and `scsynth`.
- Authorizes specific imports for Python code execution.

@dependencies
- `smolagents.local_python_executor.LocalPythonExecutor` (for Python execution)
- `python-osc` (for SuperCollider OSC communication)
- `numpy`, `soundfile`, `pathlib`, `typing`, `logging`, `phonosyne.settings`

@notes
- For `run_supercollider_code`, the provided SC `code` must be designed for OSC control.
"""

import json
import logging
import os
import select
import subprocess
import tempfile
import time
from pathlib import Path

from phonosyne import settings

# Attempt to import python-osc
try:
    from pythonosc import osc_message_builder, udp_client

    PYTHONOSC_AVAILABLE = True
except ImportError:
    PYTHONOSC_AVAILABLE = False

logger = logging.getLogger(__name__)

SCLANG_READY_SIGNAL = "Phonosyne SuperCollider script ready"


class CodeExecutionError(Exception):
    """Custom exception for errors during code execution or processing."""

    pass


class SecurityException(CodeExecutionError):  # Keep for compatibility if used elsewhere
    """Custom exception for security-related issues."""

    pass


def run_supercollider_code(
    code: str,
    output_filename: str,
    recipe_duration: float = 15.0,
    effect_name: str | None = None,
    sclang_executable_path: str = "sclang",
    scsynth_executable_path: str = "scsynth",
    sclang_osc_host: str = "127.0.0.1",
    sclang_osc_port: int = 57120,
    scsynth_udp_port: int = 57110,
) -> Path:
    """
    Executes SuperCollider code by booting scsynth, then running an sclang script
    to define SynthDefs and OSC handlers. Python then communicates with sclang via OSC
    to trigger synthesis and recording.

    Args:
        code: SuperCollider script string. This script should define SynthDefs,
              OSC handlers (e.g., for /phonosyne/render, /phonosyne/stop),
              and should NOT call 0.exit itself. It relies on Python for control.
        output_filename: Absolute path for the output .wav file.
        recipe_duration: Target duration in seconds for the audio.
        effect_name: Optional name for the effect.
        sclang_executable_path: Path to the sclang executable.
        scsynth_executable_path: Path to the scsynth executable.
        sclang_osc_host: Host for sclang's OSC server.
        sclang_osc_port: Port for sclang's OSC server.
        scsynth_udp_port: UDP port scsynth listens on.

    Returns:
        Path to the generated .wav file.

    Raises:
        CodeExecutionError: If execution fails, executables are not found,
                            OSC communication fails, or output file isn't created.
        ImportError: If python-osc is not installed.
    """
    if not PYTHONOSC_AVAILABLE:
        raise ImportError(
            "The python-osc library is required for OSC communication with SuperCollider. "
            "Please install it (e.g., pip install python-osc)."
        )

    logger.info(
        f"Initiating SuperCollider OSC-controlled execution for: '{output_filename}'"
    )
    logger.debug(f"Target duration: {recipe_duration}s, Effect name: {effect_name}")
    logger.debug(
        f"sclang: {sclang_executable_path}, scsynth: {scsynth_executable_path}"
    )
    logger.debug(
        f"sclang OSC: {sclang_osc_host}:{sclang_osc_port}, scsynth UDP: {scsynth_udp_port}"
    )

    actual_wav_path = Path(output_filename)
    if not actual_wav_path.is_absolute():
        err_msg = f"output_filename '{output_filename}' must be an absolute path."
        logger.error(err_msg)
        raise CodeExecutionError(err_msg)

    try:
        actual_wav_path.parent.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        raise CodeExecutionError(
            f"Could not create parent directory {actual_wav_path.parent}: {e}"
        ) from e

    scsynth_proc = None
    sclang_proc = None

    safe_recipe_duration = recipe_duration if recipe_duration > 0 else 15.0
    # Increased buffer for OSC model: setup time, OSC comms, file writing buffer
    operation_buffer_seconds = getattr(settings, "SCLANG_TIMEOUT_BUFFER_SECONDS", 30.0)
    overall_timeout_seconds = safe_recipe_duration + operation_buffer_seconds
    operation_start_time = time.monotonic()

    error_keywords_lower = [
        "error:",
        "failure in server",
        "doesnotunderstanderror",
        "exception:",
        "failed.",
        "syntax error",
        "parse failed",
        "segmentation fault",
        "illegal instruction",
        "address already in use",  # For server boot issues
        "server failed to start",  # Explicit scsynth failure
    ]
    scsynth_ready_signals = [
        "SuperCollider 3 server ready",
        "UDP server listening",
        "TCP server listening",  # If TCP is ever enabled by default or options
        "server ready",  # A more generic one
    ]

    try:
        # 1. Start scsynth (SuperCollider Server)
        logger.info(f"Starting scsynth (UDP port: {scsynth_udp_port})...")
        scsynth_cmd = [scsynth_executable_path, "-u", str(scsynth_udp_port)]
        try:
            scsynth_proc = subprocess.Popen(
                scsynth_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,  # Use text mode for easier parsing
                encoding="utf-8",
                errors="replace",
                bufsize=1,  # Line buffered
            )
        except FileNotFoundError:
            raise CodeExecutionError(
                f"scsynth executable not found at '{scsynth_executable_path}'. Is it in PATH?"
            )

        logger.info("Monitoring scsynth startup...")
        scsynth_boot_timeout_seconds = getattr(
            settings, "SCSYNTH_BOOT_TIMEOUT_SECONDS", 10.0
        )
        scsynth_boot_deadline = time.monotonic() + scsynth_boot_timeout_seconds
        scsynth_ready = False
        scsynth_startup_stdout = []
        scsynth_startup_stderr = []

        os.set_blocking(scsynth_proc.stdout.fileno(), False)
        os.set_blocking(scsynth_proc.stderr.fileno(), False)

        while time.monotonic() < scsynth_boot_deadline:
            if scsynth_proc.poll() is not None:
                # scsynth exited prematurely, collect output and break
                break

            ready_to_read, _, _ = select.select(
                [scsynth_proc.stdout, scsynth_proc.stderr], [], [], 0.1
            )
            for stream in ready_to_read:
                is_stdout = stream == scsynth_proc.stdout
                try:
                    for line in iter(stream.readline, ""):
                        if not line:
                            break
                        line_str = line.strip()
                        if not line_str:
                            continue

                        if is_stdout:
                            scsynth_startup_stdout.append(line_str)
                            logger.debug(f"scsynth STDOUT (boot): {line_str}")
                            for ready_signal in scsynth_ready_signals:
                                if ready_signal in line_str:
                                    scsynth_ready = True
                                    logger.info(
                                        f"scsynth ready signal detected: '{line_str}'"
                                    )
                                    break
                        else:  # stderr
                            scsynth_startup_stderr.append(line_str)
                            logger.warning(f"scsynth STDERR (boot): {line_str}")
                            # Check for critical errors in stderr as well
                            for err_kw in error_keywords_lower:
                                if err_kw in line_str.lower():
                                    # This is a critical error, scsynth likely won't become ready
                                    logger.error(
                                        f"Critical error keyword '{err_kw}' in scsynth stderr during boot: {line_str}"
                                    )
                                    # We could choose to break early here if error is fatal
                                    break
                        if scsynth_ready:
                            break
                    if scsynth_ready:
                        break
                except BlockingIOError:
                    pass
                except Exception as e_read_scsynth:
                    logger.warning(
                        f"Exception reading from scsynth during boot: {e_read_scsynth}"
                    )
                    # Potentially break or handle as a failure
                    break
            if scsynth_ready or scsynth_proc.poll() is not None:
                break

        # After loop, check status
        final_scsynth_stdout = "\\n".join(scsynth_startup_stdout)
        final_scsynth_stderr = "\\n".join(scsynth_startup_stderr)

        if not scsynth_ready and scsynth_proc.poll() is None:  # Timed out
            scsynth_proc.terminate()
            try:
                s_out, s_err = scsynth_proc.communicate(timeout=2)
                final_scsynth_stdout += ("\\n" + s_out) if s_out else ""
                final_scsynth_stderr += ("\\n" + s_err) if s_err else ""
            except subprocess.TimeoutExpired:
                scsynth_proc.kill()
                s_out, s_err = scsynth_proc.communicate(timeout=2)
                final_scsynth_stdout += ("\\n" + s_out) if s_out else ""
                final_scsynth_stderr += ("\\n" + s_err) if s_err else ""

            raise CodeExecutionError(
                f"scsynth timed out after {scsynth_boot_timeout_seconds}s. No ready signal detected.\\n"
                f"scsynth STDOUT: {final_scsynth_stdout.strip()}\\nscsynth STDERR: {final_scsynth_stderr.strip()}"
            )

        if (
            scsynth_proc.poll() is not None and not scsynth_ready
        ):  # Exited prematurely without being ready
            # Ensure all output is read if communicate wasn't called yet
            if (
                not final_scsynth_stdout and not final_scsynth_stderr
            ):  # if buffers are empty, try communicate
                s_out, s_err = scsynth_proc.communicate(
                    timeout=2
                )  # Already exited, so communicate should be fast
                final_scsynth_stdout = s_out or ""
                final_scsynth_stderr = s_err or ""

            raise CodeExecutionError(
                f"scsynth failed to start or exited prematurely. Exit code: {scsynth_proc.returncode}.\\n"
                f"scsynth STDOUT: {final_scsynth_stdout.strip()}\\nscsynth STDERR: {final_scsynth_stderr.strip()}"
            )

        logger.info("scsynth started successfully and is presumed ready.")

        # 2. Start sclang and send the script via stdin
        logger.info("Preparing to start sclang and send script via stdin.")
        logger.info(
            f"sclang should listen for OSC on {sclang_osc_host}:{sclang_osc_port}"
        )

        # The SC 'code' must be adapted for this OSC model.
        # It should NOT boot its own server or call 0.exit.
        # It should define OSCdefs listening on sclang_osc_port.
        # If sclang_osc_port is not the default 57120, the SC code *must* set NetAddr.langPort.
        # We could prepend this, but it's better if the user's script is aware.
        # For now, assume user's script handles its listening port or uses default 57120.

        script_content_preview_lines = code.splitlines()[:10]
        script_content_preview = "\\n".join(script_content_preview_lines)
        logger.debug(
            f"Preview of SC script content (up to 10 lines):\\n{script_content_preview.strip()}"
        )

        sclang_cmd = [sclang_executable_path]  # No script file argument
        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"  # Ensure consistent encoding for sclang
        env["LC_ALL"] = "en_US.UTF-8"

        logger.info(f"Executing sclang command: {' '.join(sclang_cmd)}")
        try:
            sclang_proc = subprocess.Popen(
                sclang_cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,  # Use text mode (universal_newlines=True)
                encoding="utf-8",  # Specify encoding
                errors="replace",  # Handle potential decoding errors
                bufsize=1,  # Line buffered
                env=env,
                start_new_session=True,  # Ensure sclang runs in its own session
            )
            logger.info(f"sclang started with PID: {sclang_proc.pid}")

            # Send the SuperCollider code to sclang's stdin
            if sclang_proc.stdin:
                logger.debug("Writing SC script to sclang stdin...")
                sclang_proc.stdin.write(code)
                sclang_proc.stdin.write(
                    "\\n\\u000c\\n"
                )  # Form feed to execute, surrounded by newlines
                sclang_proc.stdin.flush()
                # DO NOT CLOSE stdin - sclang would exit.
                logger.debug("SC script written and flushed to sclang stdin.")
            else:
                raise CodeExecutionError("sclang process stdin is not available.")

            # Initial check for immediate sclang errors or exit
            time.sleep(
                0.75
            )  # Increased slightly for text mode and potential initial output
            if sclang_proc.poll() is not None:  # sclang has already exited
                sclang_initial_stdout, sclang_initial_stderr = sclang_proc.communicate(
                    timeout=5
                )  # timeout to prevent hang
                raise CodeExecutionError(
                    f"sclang failed to start or exited prematurely immediately after script submission. Exit code: {sclang_proc.returncode}.\\\\n"
                    f"Initial sclang STDOUT: {sclang_initial_stdout}\\\\n"
                    f"Initial sclang STDERR: {sclang_initial_stderr}"
                )
            logger.info(
                "sclang process started, script submitted, and did not exit immediately. Proceeding to monitor for ready signal."
            )

        except FileNotFoundError:
            raise CodeExecutionError(
                f"sclang executable not found at '{sclang_executable_path}'. Is it in PATH?"
            )
        except subprocess.TimeoutExpired:
            raise CodeExecutionError(
                "Timeout during initial communication with sclang after script submission."
            )

        os.set_blocking(sclang_proc.stdout.fileno(), False)
        os.set_blocking(sclang_proc.stderr.fileno(), False)

        sclang_stdout_acc = []  # Store lines of stdout
        sclang_stderr_acc = []  # Store lines of stderr
        sclang_setup_error_message = None

        sclang_setup_deadline = time.monotonic() + settings.SCLANG_SETUP_TIMEOUT_SECONDS

        logger.info("Monitoring sclang setup script output (text mode)...")
        initial_setup_phase_done = False

        while time.monotonic() < sclang_setup_deadline:
            if sclang_proc.poll() is not None:
                sclang_setup_error_message = (
                    "sclang process terminated prematurely during setup "
                    f"(exit code {sclang_proc.returncode})."
                )
                logger.error(sclang_setup_error_message)
                break

            ready_to_read, _, _ = select.select(
                [sclang_proc.stdout, sclang_proc.stderr], [], [], 0.1
            )
            for stream in ready_to_read:
                is_stdout = stream == sclang_proc.stdout
                try:
                    # Read available lines in text mode
                    for line in iter(stream.readline, ""):  # Read line by line
                        if (
                            not line
                        ):  # Empty string can mean EOF or just no more lines now
                            break

                        line_str = line.strip()
                        if not line_str:
                            continue

                        current_buffer_acc = (
                            sclang_stdout_acc if is_stdout else sclang_stderr_acc
                        )
                        current_buffer_acc.append(line_str)

                        log_level = logging.INFO if is_stdout else logging.WARNING
                        logger.log(
                            log_level,
                            f"sclang {'STDOUT' if is_stdout else 'STDERR'} (setup): {line_str}",
                        )

                        if is_stdout and SCLANG_READY_SIGNAL in line_str:
                            logger.info(
                                f"Detected sclang ready signal: '{SCLANG_READY_SIGNAL}'"
                            )
                            initial_setup_phase_done = True
                            # No need to break inner loop, consume all current output

                        for keyword in error_keywords_lower:
                            if keyword in line_str.lower():
                                sclang_setup_error_message = f"Error keyword '{keyword}' in sclang output: {line_str}"
                                logger.error(sclang_setup_error_message)
                                break
                        if sclang_setup_error_message:
                            break

                except BlockingIOError:
                    pass  # Expected with non-blocking reads if readline has nothing.
                except Exception as e_read:
                    logger.warning(
                        f"Exception reading from sclang during setup: {e_read}"
                    )
                    sclang_setup_error_message = f"Read exception: {e_read}"
                    break
            if sclang_setup_error_message or initial_setup_phase_done:
                break

        if (
            not initial_setup_phase_done and not sclang_setup_error_message
        ):  # Check if loop finished due to timeout
            if time.monotonic() >= sclang_setup_deadline:
                sclang_setup_error_message = f"sclang setup timed out after {settings.SCLANG_SETUP_TIMEOUT_SECONDS:.1f}s waiting for ready signal."
                logger.error(sclang_setup_error_message)

        if (
            sclang_setup_error_message
        ):  # Error during setup or premature exit or timeout
            # Try to capture any final output
            # communicate() is better for final capture with text=True
            sclang_final_stdout_communicate, sclang_final_stderr_communicate = "", ""
            if (
                sclang_proc.poll() is None
            ):  # if still running, try to get output before terminating
                try:
                    sclang_proc.terminate()  # Ask it to terminate
                    sclang_final_stdout_communicate, sclang_final_stderr_communicate = (
                        sclang_proc.communicate(timeout=2)
                    )
                except subprocess.TimeoutExpired:
                    sclang_proc.kill()
                    sclang_final_stdout_communicate, sclang_final_stderr_communicate = (
                        sclang_proc.communicate(timeout=2)
                    )  # get output after kill
            else:  # already terminated
                sclang_final_stdout_communicate, sclang_final_stderr_communicate = (
                    sclang_proc.communicate(timeout=2)
                )

            full_stdout = (
                "\\n".join(sclang_stdout_acc)
                + "\\n"
                + (sclang_final_stdout_communicate or "")
            )
            full_stderr = (
                "\\n".join(sclang_stderr_acc)
                + "\\n"
                + (sclang_final_stderr_communicate or "")
            )

            raise CodeExecutionError(
                f"Failed to set up sclang script: {sclang_setup_error_message}\\n"
                f"sclang STDOUT: {full_stdout.strip()}\\n"
                f"sclang STDERR: {full_stderr.strip()}"
            )

        if (
            not initial_setup_phase_done and time.monotonic() >= sclang_setup_deadline
        ):  # Timed out waiting for setup
            sclang_final_stdout_communicate, sclang_final_stderr_communicate = (
                sclang_proc.communicate(timeout=5)
            )
            full_stdout = (
                "\\n".join(sclang_stdout_acc)
                + "\\n"
                + (sclang_final_stdout_communicate or "")
            )
            full_stderr = (
                "\\n".join(sclang_stderr_acc)
                + "\\n"
                + (sclang_final_stderr_communicate or "")
            )
            raise CodeExecutionError(
                f"sclang setup script timed out after {settings.SCLANG_SETUP_TIMEOUT_SECONDS:.1f}s.\\n"
                f"sclang STDOUT: {full_stdout.strip()}\\n"
                f"sclang STDERR: {full_stderr.strip()}"
            )

        logger.info("sclang setup script processed. Proceeding with OSC control.")

        # 3. Python OSC Interaction with sclang
        osc_client = udp_client.UDPClient(sclang_osc_host, sclang_osc_port)

        # SC script needs OSCdefs for these paths, e.g.:
        # OSCdef(\\render, { |msg| var path=msg[1], dur=msg[2], effect=msg[3]; /* record logic */ }, '/phonosyne/render');
        # OSCdef(\\stop, { /* stop recording, free synth */ }, '/phonosyne/stop');

        logger.info(
            f"Sending /phonosyne/render OSC message to sclang ({sclang_osc_host}:{sclang_osc_port})"
        )
        render_msg_builder = osc_message_builder.OscMessageBuilder(
            address="/phonosyne/render"
        )
        render_msg_builder.add_string(str(actual_wav_path))
        render_msg_builder.add_float(safe_recipe_duration)
        # The SC script OSCdef for /phonosyne/render expects: path (string), duration (float)
        # The effect_name was removed from the SC script's OSCdef for /phonosyne/render
        # render_msg_builder.add_string(effect_name if effect_name else "unknown_effect")
        osc_client.send(render_msg_builder.build())

        logger.info(
            f"Waiting for recipe duration ({safe_recipe_duration}s) while sclang/scsynth operate..."
        )

        # Monitor sclang output and overall timeout during recipe duration
        recipe_end_time = time.monotonic() + safe_recipe_duration
        timed_out_during_recipe = False

        while time.monotonic() < recipe_end_time:
            if (time.monotonic() - operation_start_time) > overall_timeout_seconds:
                logger.error(
                    "Overall operation timeout reached during recipe execution."
                )
                timed_out_during_recipe = True
                break
            if sclang_proc.poll() is not None:
                logger.error(
                    f"sclang process terminated unexpectedly during recipe execution (exit code {sclang_proc.returncode})."
                )
                sclang_final_stdout_recipe, sclang_final_stderr_recipe = (
                    sclang_proc.communicate(timeout=5)
                )
                full_stdout_recipe = (
                    "\\n".join(sclang_stdout_acc)
                    + "\\n"
                    + (sclang_final_stdout_recipe or "")
                )
                full_stderr_recipe = (
                    "\\n".join(sclang_stderr_acc)
                    + "\\n"
                    + (sclang_final_stderr_recipe or "")
                )
                raise CodeExecutionError(
                    f"sclang exited prematurely during recipe.\\nSTDOUT: {full_stdout_recipe.strip()}\\nSTDERR: {full_stderr_recipe.strip()}"
                )

            ready_to_read, _, _ = select.select(
                [sclang_proc.stdout, sclang_proc.stderr], [], [], 0.2
            )
            for stream in ready_to_read:
                try:
                    for line in iter(stream.readline, ""):  # Read line by line
                        if not line:
                            break
                        line_str = line.strip()
                        if line_str:
                            is_stdout = stream == sclang_proc.stdout
                            current_buffer_acc = (
                                sclang_stdout_acc if is_stdout else sclang_stderr_acc
                            )
                            current_buffer_acc.append(line_str)
                            logger.info(
                                f"sclang {'STDOUT' if is_stdout else 'STDERR'} (recipe): {line_str}"
                            )
                except BlockingIOError:
                    pass
                except Exception as e_read_recipe:
                    logger.warning(
                        f"Exception reading from sclang during recipe: {e_read_recipe}"
                    )

        if timed_out_during_recipe:
            raise CodeExecutionError(
                "Overall operation timeout during recipe execution."
            )

        logger.info(
            f"Recipe duration elapsed. Sending /phonosyne/stop OSC message to sclang ({sclang_osc_host}:{sclang_osc_port})"
        )
        stop_msg_builder = osc_message_builder.OscMessageBuilder(
            address="/phonosyne/stop"
        )
        osc_client.send(stop_msg_builder.build())

        # Wait a moment for sclang to process the stop message and finish writing file
        stop_processing_time = getattr(
            settings, "SCLANG_STOP_PROCESSING_TIME_SECONDS", 5.0
        )
        logger.info(
            f"Waiting {stop_processing_time}s for sclang to process stop and finalize recording..."
        )

        stop_wait_start_time = time.monotonic()
        while time.monotonic() < stop_wait_start_time + stop_processing_time:
            if sclang_proc.poll() is not None:
                logger.warning(
                    f"sclang process terminated during stop processing time (exit code {sclang_proc.returncode})."
                )
                break  # sclang already exited, no need to wait further

            # Drain any remaining output from sclang during this wait
            ready_to_read, _, _ = select.select(
                [sclang_proc.stdout, sclang_proc.stderr], [], [], 0.1
            )
            for stream in ready_to_read:
                try:
                    for line in iter(stream.readline, ""):  # Read line by line
                        if not line:
                            break
                        line_str = line.strip()
                        if line_str:
                            is_stdout = stream == sclang_proc.stdout
                            current_buffer_acc = (
                                sclang_stdout_acc if is_stdout else sclang_stderr_acc
                            )
                            current_buffer_acc.append(line_str)
                            logger.log(
                                logging.INFO if is_stdout else logging.WARNING,
                                f"sclang {'STDOUT' if is_stdout else 'STDERR'} (post-stop): {line_str}",
                            )
                except BlockingIOError:
                    pass
                except Exception as e_drain:
                    logger.warning(
                        f"Exception draining sclang output post-stop: {e_drain}"
                    )
                    break  # Stop trying to drain if error

            time.sleep(0.1)  # Brief sleep to avoid busy-waiting if no output

        logger.info("Finished waiting for sclang stop processing.")

    except osc_message_builder.BuildError as e_osc_build:
        raise CodeExecutionError(
            f"Failed to build OSC message: {e_osc_build}"
        ) from e_osc_build
    except Exception as e_general:
        # Ensure processes are cleaned up if an unexpected error occurs mid-flight
        if sclang_proc and sclang_proc.poll() is None:
            logger.warning(f"Terminating sclang due to exception: {e_general}")
            sclang_proc.terminate()
            try:
                sclang_proc.wait(timeout=5)
            except subprocess.TimeoutExpired:
                logger.warning("sclang did not terminate gracefully, killing.")
                sclang_proc.kill()
        if scsynth_proc and scsynth_proc.poll() is None:
            logger.warning(f"Terminating scsynth due to exception: {e_general}")
            scsynth_proc.terminate()
            try:
                scsynth_proc.wait(timeout=5)
            except subprocess.TimeoutExpired:
                logger.warning("scsynth did not terminate gracefully, killing.")
                scsynth_proc.kill()
        raise CodeExecutionError(
            f"An unexpected error occurred: {e_general}"
        ) from e_general

    finally:
        logger.info("Cleaning up SuperCollider processes (OSC model)...")

        # Terminate sclang first, as it might be controlling scsynth
        if sclang_proc and sclang_proc.poll() is None:
            logger.info("Terminating sclang process...")
            sclang_proc.terminate()
            try:
                sclang_proc.wait(timeout=5.0)  # Wait for graceful termination
                logger.info("sclang process terminated.")
            except subprocess.TimeoutExpired:
                logger.warning("sclang process did not terminate gracefully, killing.")
                sclang_proc.kill()
                try:
                    sclang_proc.wait(timeout=2.0)
                except subprocess.TimeoutExpired:
                    logger.error("sclang process failed to die even after kill.")
            # Capture any final output
            if sclang_proc.stdout:
                sclang_stdout_acc.append(sclang_proc.stdout.readall() or b"")
            if sclang_proc.stderr:
                sclang_stderr_acc.append(sclang_proc.stderr.readall() or b"")

            sclang_final_stdout = "\\n".join(filter(None, sclang_stdout_acc)).strip()
            sclang_final_stderr = "\\n".join(filter(None, sclang_stderr_acc)).strip()
            if sclang_final_stdout:
                logger.debug(
                    f"Final accumulated sclang STDOUT:\\n{sclang_final_stdout}"
                )
            if sclang_final_stderr:
                logger.debug(
                    f"Final accumulated sclang STDERR:\\n{sclang_final_stderr}"
                )

        if scsynth_proc and scsynth_proc.poll() is None:
            logger.info("Terminating scsynth process...")
            scsynth_proc.terminate()
            try:
                scsynth_proc.wait(timeout=5.0)
                logger.info("scsynth process terminated.")
            except subprocess.TimeoutExpired:
                logger.warning("scsynth process did not terminate gracefully, killing.")
                scsynth_proc.kill()
                try:
                    scsynth_proc.wait(timeout=2.0)
                except subprocess.TimeoutExpired:
                    logger.error("scsynth process failed to die even after kill.")
            # Capture any final output from scsynth
            scsynth_stdout_final_bytes = (
                scsynth_proc.stdout.readall() if scsynth_proc.stdout else b""
            )
            scsynth_stderr_final_bytes = (
                scsynth_proc.stderr.readall() if scsynth_proc.stderr else b""
            )
            if scsynth_stdout_final_bytes:
                logger.debug(
                    f"Final scsynth STDOUT:\\n{scsynth_stdout_final_bytes.decode('utf-8',errors='replace')}"
                )
            if scsynth_stderr_final_bytes:
                logger.debug(
                    f"Final scsynth STDERR:\\n{scsynth_stderr_final_bytes.decode('utf-8',errors='replace')}"
                )

    if not actual_wav_path.exists() or not actual_wav_path.is_file():
        final_stdout_for_error = "\\n".join(filter(None, sclang_stdout_acc)).strip()
        final_stderr_for_error = "\\n".join(filter(None, sclang_stderr_acc)).strip()
        raise CodeExecutionError(
            f"Output .wav file not found at {actual_wav_path} after OSC-controlled execution.\\n"
            f"Final sclang STDOUT:\\n{final_stdout_for_error}\\n"
            f"Final sclang STDERR:\\n{final_stderr_for_error}"
        )

    logger.info(
        f"Successfully produced WAV file via OSC-controlled SuperCollider: {actual_wav_path}"
    )
    return actual_wav_path


# If you have a run_python_code function, it would go here.
# For example:
# def run_python_code(code: str, output_filename: str, recipe_duration: float, effect_name: str | None = None) -> Path:
#     logger.warning("run_python_code is not fully implemented in this refactoring pass.")
#     # ... (original run_python_code logic if it exists and is separate) ...
#     raise NotImplementedError("run_python_code needs to be reviewed/reinstated if used.")
