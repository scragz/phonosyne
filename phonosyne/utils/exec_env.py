"""
Execution Environment for Dynamically Generated Code

This module provides a secure environment for executing Python code generated by Phonosyne agents
using smolagents.LocalPythonExecutor to analyze AST and restrict operations/imports.

Key features:
- `run_code` function to execute a string of Python code.
- Authorizes specific imports (numpy, scipy, soundfile, math, random).
- Expects the executed code to write audio data directly to the specified output file.
- Verifies the file exists and returns its path after execution.

@dependencies
- `smolagents.local_python_executor.LocalPythonExecutor`
- `numpy` (for DSP operations in generated code)
- `soundfile` (for writing the WAV file in generated code)
- `pathlib.Path`, `typing`, `logging`
- `phonosyne.settings`

@notes
- The generated code must write the audio file directly using the provided output_filename.
- The system verifies the file exists after execution.
"""

import json
import logging
import subprocess
import tempfile
from pathlib import Path

import numpy as np

from phonosyne import settings

logger = logging.getLogger(__name__)

# <<< BEGIN MONKEY PATCH FOR scipy.sparse.coo.upcast >>>
# This patch is to support LLM-generated code that might still refer to
# scipy.sparse.coo.upcast, which has been removed from modern SciPy versions.
# We attempt to add it to the underlying scipy.sparse._coo module.
_monkey_patch_logger = logging.getLogger(__name__ + ".monkey_patch")

try:
    import scipy.sparse._coo as scipy_coo_module

    # numpy is imported as np above

    if not hasattr(scipy_coo_module, "upcast"):

        def _upcast_shim(*args):
            """
            Shim for the removed scipy.sparse.coo.upcast.
            Returns the nearest common type of a sequence of dtypes.
            Based on numpy.find_common_type.
            """
            dtype_objects = [np.dtype(arg) for arg in args]
            return np.find_common_type(dtype_objects, [])

        scipy_coo_module.upcast = _upcast_shim
        _monkey_patch_logger.info(
            "Successfully monkey-patched scipy.sparse._coo.upcast to restore functionality "
            "for LLM-generated code."
        )
    else:
        _monkey_patch_logger.info(
            "scipy.sparse._coo.upcast already exists. No monkey patch applied."
        )
except ImportError:
    _monkey_patch_logger.warning(
        "Could not import scipy.sparse._coo to attempt monkey-patching for upcast. "
        "If LLM-generated code relies on a patched scipy.sparse.coo.upcast, it may fail."
    )
except Exception as e:
    _monkey_patch_logger.error(
        f"An unexpected error occurred while trying to monkey-patch scipy.sparse._coo.upcast: {e}",
        exc_info=True,
    )


class CodeExecutionError(Exception):
    """Custom exception for errors during code execution or processing."""

    pass


class SecurityException(CodeExecutionError):  # Keep for compatibility if used elsewhere
    """Custom exception for security-related issues."""

    pass


def run_supercollider_code(
    code: str,
    output_filename: str,
    recipe_duration: float = 15.0,
    effect_name: str | None = None,
    sclang_path: str = "sclang",
) -> Path:
    """
    Executes SuperCollider code that writes a .wav file and returns its path.

    The SuperCollider code is expected to handle its own server interaction (e.g.,
    booting if necessary, though for now a running server is assumed), synthesis,
    and writing audio data directly to a file at the specified output_filename.
    This function writes the code to a temporary .scd file, executes it using sclang,
    verifies the output file exists, and returns its path.

    Args:
        code: The SuperCollider code string to execute.
        output_filename: Absolute path for the output .wav file. The SC script
                         must write to this exact path.
        recipe_duration: The target duration in seconds for the audio.
        effect_name: Optional name for the effect.
        sclang_path: Path to the sclang executable.

    Returns:
        Path to the generated .wav file.

    Raises:
        CodeExecutionError: If code execution fails, sclang is not found,
                            or the output file doesn't exist.
    """
    logger.info(f"Executing SuperCollider code for target output: '{output_filename}'")
    code_to_log = code[:500] + "..." if len(code) > 500 else code
    logger.debug(f"SuperCollider code (first 500 chars):\\n{code_to_log}")
    logger.debug(f"Target duration for context: {recipe_duration}s")
    logger.debug(f"Effect name for context: {effect_name}")

    actual_wav_path = Path(output_filename)
    if not actual_wav_path.is_absolute():
        err_msg = f"output_filename '{output_filename}' must be an absolute path."
        logger.error(err_msg)
        raise CodeExecutionError(err_msg)

    # Ensure parent directory for the output .wav file exists
    try:
        actual_wav_path.parent.mkdir(parents=True, exist_ok=True)
        logger.info(f"Ensured output directory exists: {actual_wav_path.parent}")
    except OSError as e:
        err_msg = f"Could not create parent directory {actual_wav_path.parent} for output file: {e}"
        logger.error(err_msg)
        raise CodeExecutionError(err_msg) from e

    temp_scd_file_path_str: str | None = None
    try:
        # Create a temporary .scd file to hold the SuperCollider code.
        # The CompilerAgent is responsible for ensuring 'code' uses output_filename, recipe_duration etc.
        with tempfile.NamedTemporaryFile(
            mode="w", suffix=".scd", delete=False, encoding="utf-8"
        ) as tmp_f:
            tmp_f.write(code)
            temp_scd_file_path_str = tmp_f.name
        logger.info(
            f"SuperCollider code written to temporary file: {temp_scd_file_path_str}"
        )

        cmd = [sclang_path, temp_scd_file_path_str]
        logger.info(f"Executing command: {' '.join(cmd)}")

        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding="utf-8",
        )

        # Calculate timeout: recipe_duration + buffer (e.g., 60 seconds)
        # Ensure recipe_duration is positive, default to a base if not sensible.
        safe_recipe_duration = (
            recipe_duration if recipe_duration > 0 else 15.0
        )  # Default to 15s if duration is zero or negative
        timeout_seconds = safe_recipe_duration + 10.0  # Add 10 seconds buffer
        logger.info(f"sclang process timeout set to: {timeout_seconds:.2f} seconds")

        stdout = ""
        stderr = ""
        timed_out = False

        try:
            stdout, stderr = process.communicate(timeout=timeout_seconds)
        except subprocess.TimeoutExpired:
            logger.error(
                f"sclang process timed out after {timeout_seconds:.2f} seconds for {temp_scd_file_path_str}."
            )
            process.kill()  # Ensure the process is terminated
            # Try to get any remaining output after killing
            try:
                stdout_after_kill, stderr_after_kill = process.communicate(
                    timeout=5
                )  # Short timeout for cleanup
                stdout += stdout_after_kill
                stderr += stderr_after_kill
            except Exception as e_comm_kill:
                logger.warning(
                    f"Error getting output after killing timed-out sclang process: {e_comm_kill}"
                )
            timed_out = True
            # Ensure returncode is set, as it might not be if killed due to timeout before normal exit
            if process.returncode is None:
                # Simulate a non-zero exit code for timeout scenarios if not already set
                # This helps existing error detection logic.
                # However, Popen objects might not allow setting returncode directly.
                # The 'timed_out' flag will be the primary indicator.
                pass  # process.returncode will be what it is after kill (often -SIGTERM or similar)

        # Check for errors based on return code OR specific stderr content OR timeout
        error_detected = False
        # Prepare a detailed message for logging, in case of errors or for verbose debugging
        full_process_output_details = (
            f"sclang process details for {temp_scd_file_path_str} (targeting {output_filename}):\\n"
            f"Return code: {process.returncode}\\n"
            f"STDOUT:\\n{stdout}\\n"
            f"STDERR:\\n{stderr}"
        )

        if timed_out:
            logger.error(
                f"sclang execution failed due to timeout.\\n{full_process_output_details}"
            )
            error_detected = True
        elif process.returncode != 0:
            logger.error(
                f"sclang execution failed with non-zero exit code.\\n{full_process_output_details}"
            )
            error_detected = True
        elif stderr:  # Check stderr even if return code is 0
            # Common SuperCollider error indicators, checked case-insensitively
            error_keywords_lower = [
                "error:",
                "primitive",
                "failure in server",
                "failure /n",
                "doesnotunderstanderror",
                "exception:",
                "failed.",
                "hang",
                "segmentation fault",
                "illegal instruction",
                "server not running",  # General server issue
                "localhost not running", # Specific to localhost, common default
                "could not send synthdef", # Specific error from user log
                "not understood", # For messages like "'disable' not understood"
            ]
            stderr_lower = stderr.lower()
            for keyword in error_keywords_lower:
                if keyword in stderr_lower:
                    logger.error(
                        f"sclang execution reported errors in STDERR (keyword: '{keyword}') "
                        f"despite exit code {process.returncode}.\\n{full_process_output_details}"
                    )
                    error_detected = True
                    break

        if error_detected:
            # Construct a potentially truncated message for the exception
            max_stdout_len = 1000
            stdout_for_exception = stdout[:max_stdout_len] + (
                "..." if len(stdout) > max_stdout_len else ""
            )

            exception_message = (
                f"sclang execution failed or reported errors for {temp_scd_file_path_str} (targeting {output_filename}).\\n"
                f"Return code: {process.returncode}. Check logs for full STDOUT/STDERR.\\n"
                f"STDOUT (up to {max_stdout_len} chars):\\n{stdout_for_exception}\\n"
                f"STDERR:\\n{stderr}"
            )
            raise CodeExecutionError(exception_message)
        else:
            # This means return code is 0 AND no critical errors found in stderr
            logger.info(f"sclang execution successful for {temp_scd_file_path_str}.")
            # Log STDOUT and STDERR (if any) at debug level for successful runs
            logger.debug(f"sclang STDOUT for {temp_scd_file_path_str}:\\n{stdout}")
            if stderr:
                logger.debug(
                    f"sclang STDERR (non-critical, warnings, etc.) for {temp_scd_file_path_str}:\\n{stderr}"
                )

    except FileNotFoundError:
        err_msg = f"sclang executable not found at '{sclang_path}'. Please ensure SuperCollider is installed and sclang is in your PATH or provide the correct path."
        logger.error(err_msg)
        raise CodeExecutionError(err_msg)
    except Exception as e:
        error_message = f"An unexpected error occurred during SuperCollider code execution for {output_filename}: {e}"
        logger.error(error_message, exc_info=True)
        raise CodeExecutionError(error_message) from e
    finally:
        if temp_scd_file_path_str and Path(temp_scd_file_path_str).exists():
            try:
                Path(temp_scd_file_path_str).unlink()
                logger.info(
                    f"Successfully deleted temporary .scd file: {temp_scd_file_path_str}"
                )
            except OSError as e_unlink:
                logger.warning(
                    f"Could not delete temporary .scd file {temp_scd_file_path_str}: {e_unlink}"
                )

    if not actual_wav_path.exists() or not actual_wav_path.is_file():
        error_message = (
            f"SuperCollider script ran but the output .wav file was not found at {actual_wav_path}.\\n"
            f"Check sclang STDOUT/STDERR above for clues from the script itself."
        )
        logger.error(error_message)
        raise CodeExecutionError(error_message)

    logger.info(f"Successfully produced WAV file via SuperCollider: {actual_wav_path}")
    return actual_wav_path
