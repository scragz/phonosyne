"""
Execution Environment for Dynamically Generated Code

This module provides a secure environment for executing Python code generated by Phonosyne agents
using smolagents.LocalPythonExecutor to analyze AST and restrict operations/imports.

Key features:
- `run_code` function to execute a string of Python code.
- Authorizes specific imports (numpy, scipy, soundfile, math, random).
- Expects the executed code to write audio data directly to the specified output file.
- Verifies the file exists and returns its path after execution.

@dependencies
- `smolagents.local_python_executor.LocalPythonExecutor`
- `numpy` (for DSP operations in generated code)
- `soundfile` (for writing the WAV file in generated code)
- `pathlib.Path`, `typing`, `logging`
- `phonosyne.settings`

@notes
- The generated code must write the audio file directly using the provided output_filename.
- The system verifies the file exists after execution.
"""

import array
import importlib
import json
import logging
import math
import random
import shutil
import tempfile
import time
import traceback
from pathlib import Path
from typing import Any, Dict, Tuple

import numpy as np
import scipy
import soundfile as sf
import supriya
from smolagents.local_python_executor import InterpreterError, LocalPythonExecutor

from phonosyne import settings

logger = logging.getLogger(__name__)

# <<< BEGIN MONKEY PATCH FOR scipy.sparse.coo.upcast >>>
# This patch is to support LLM-generated code that might still refer to
# scipy.sparse.coo.upcast, which has been removed from modern SciPy versions.
# We attempt to add it to the underlying scipy.sparse._coo module.
_monkey_patch_logger = logging.getLogger(__name__ + ".monkey_patch")

try:
    import scipy.sparse._coo as scipy_coo_module

    # numpy is imported as np above

    if not hasattr(scipy_coo_module, "upcast"):

        def _upcast_shim(*args):
            """
            Shim for the removed scipy.sparse.coo.upcast.
            Returns the nearest common type of a sequence of dtypes.
            Based on numpy.find_common_type.
            """
            dtype_objects = [np.dtype(arg) for arg in args]
            return np.find_common_type(dtype_objects, [])

        scipy_coo_module.upcast = _upcast_shim
        _monkey_patch_logger.info(
            "Successfully monkey-patched scipy.sparse._coo.upcast to restore functionality "
            "for LLM-generated code."
        )
    else:
        _monkey_patch_logger.info(
            "scipy.sparse._coo.upcast already exists. No monkey patch applied."
        )
except ImportError:
    _monkey_patch_logger.warning(
        "Could not import scipy.sparse._coo to attempt monkey-patching for upcast. "
        "If LLM-generated code relies on a patched scipy.sparse.coo.upcast, it may fail."
    )
except Exception as e:
    _monkey_patch_logger.error(
        f"An unexpected error occurred while trying to monkey-patch scipy.sparse._coo.upcast: {e}",
        exc_info=True,
    )
# <<< END MONKEY PATCH FOR scipy.sparse.coo.upcast >>>

# No restricted globals needed as we only use LocalPythonExecutor

# Authorized imports for LocalPythonExecutor
# Based on compiler.md: numpy, scipy.signal, soundfile as sf, plus random, math
# os, tempfile, time, json, sys are generally unsafe for LLM code.
# LocalPythonExecutor has its own defaults, we add to them or specify a full list.
# Common safe DSP modules:
AUTHORIZED_IMPORTS_FOR_DSP = [
    "supriya",
    "supriya.*",
    "numpy",  # For numerical arrays and operations
    "numpy.*",
    "math",  # Basic math functions
    "random",  # For random number generation
    "time",  # For time-related functions, scheduling
    "time.*",
    "traceback",  # For detailed error reporting
    "pathlib",  # For object-oriented path manipulation
    "soundfile",  # For Python-side audio file I/O to/from numpy arrays
    "soundfile.*",
    "scipy",  # For advanced Python-side signal processing
    "scipy.*",
    "phonosyne.dsp.effects",
    "phonosyne.dsp.effects.*",
    "phonosyne.settings",
]


class CodeExecutionError(Exception):
    """Custom exception for errors during code execution or processing."""

    pass


class SecurityException(CodeExecutionError):  # Keep for compatibility if used elsewhere
    """Custom exception for security-related issues."""

    pass


def run_code(
    code: str,
    output_filename: str,
    recipe_duration: float = 15.0,
    effect_name: str | None = None,
) -> Path:
    """
    Executes Python code that writes a .wav file and returns its path.

    Uses LocalPythonExecutor to safely execute generated code. The code is expected to
    write audio data directly to a file at the specified output_filename. This function
    verifies the file exists after execution and returns its path.

    Args:
        code: The Python code string to execute.
        output_filename: Desired name for the output .wav file (e.g., "sample_01.wav").
        recipe_duration: The target duration in seconds for the audio.
        effect_name: Optional name for the effect.

    Returns:
        Path to the generated .wav file.

    Raises:
        CodeExecutionError: If code execution fails or the output file doesn't exist.
    """
    # Sanitize the input code string to remove null bytes
    if "\x00" in code:
        logger.warning(
            f"Null bytes found in input code for {output_filename}. Sanitizing..."
        )
        code = code.replace("\x00", "")

    logger.info(f"Executing code for target output: {output_filename}")
    logger.debug(f"Target duration for context: {recipe_duration}s")
    logger.debug(f"Effect name for context: {effect_name}")
    logger.debug(f"--- BEGIN Python DSP Code to Execute for {output_filename} ---")
    for i, line in enumerate(code.splitlines()):
        logger.debug(f"{i+1:03d} | {line}")
    logger.debug(f"--- END Python DSP Code for {output_filename} ---")

    persistent_temp_dir = settings.DEFAULT_OUT_DIR / "exec_env_output"
    persistent_temp_dir = persistent_temp_dir.absolute()
    persistent_temp_dir.mkdir(parents=True, exist_ok=True)

    logger.info(f"Target output directory for WAV: {persistent_temp_dir}")

    original_tempdir = tempfile.tempdir
    tempfile.tempdir = str(persistent_temp_dir)
    logger.info(f"Temporarily set tempfile.tempdir to: {tempfile.tempdir}")

    try:
        # Extract just the filename without any path components
        # This ensures we don't accidentally create nested paths
        safe_filename = Path(output_filename).name
        if not safe_filename or safe_filename in (".", ".."):
            error_msg = f"Invalid output_filename provided: '{output_filename}'. Must be a valid filename."
            logger.error(error_msg)
            raise CodeExecutionError(error_msg)

        # Create a Path object for the final intended output
        actual_wav_path = persistent_temp_dir / safe_filename
        logger.info(f"Full output path will be: {actual_wav_path}")

        executor = LocalPythonExecutor(
            additional_authorized_imports=AUTHORIZED_IMPORTS_FOR_DSP
        )

        modules_as_variables = {
            "supriya": supriya,
            "sf": sf,
            "soundfile": sf,
            "np": np,
            "numpy": np,
            "scipy": scipy,
            "math": math,
            "random": random,
            "array": array,
            "json": json,
            "pathlib": Path,
            "traceback": traceback,
            "time": time,
            "settings": settings,
        }

        # Prepare functions/callables to be sent as tools
        functions_as_tools = {
            "hash": hash,
        }

        # Combine recipe-specific variables with modules for send_variables
        variables_for_executor = {
            "output_filename": str(actual_wav_path),  # Pass the full path
            "duration": recipe_duration,
            "effect_name": effect_name,
            **modules_as_variables,
        }
        logger.debug(
            f"Variables prepared for LocalPythonExecutor: {list(variables_for_executor.keys())}"
        )

        try:
            logger.debug(
                f"Attempting to execute code in LocalPythonExecutor for {actual_wav_path}..."
            )
            # Execute the code. The code is expected to use 'output_filename' variable.
            # LocalPythonExecutor returns the result of the last expression or None.
            # We are relying on the code to write the file, not on a return value here.
            executor.send_variables(variables_for_executor)
            executor.send_tools(functions_as_tools)
            code_output, logs, is_final_answer = executor(code)
            logger.debug(
                f"LocalPythonExecutor raw output (result of executed code) for {output_filename}: {code_output!r}"
            )
            logger.debug(f"LocalPythonExecutor logs for {output_filename}: {logs!r}")
            if is_final_answer:
                logger.info(
                    f"LocalPythonExecutor produced final answer for {output_filename}"
                )

        except InterpreterError as e:
            error_message = f"Code execution failed with InterpreterError for {output_filename}: {e}"
            logger.error(error_message, exc_info=True)  # Log with traceback
            # Include more details from the error if available and helpful
            # For example, e.stdout and e.stderr if they exist and are populated
            if hasattr(e, "stdout") and e.stdout:
                logger.error(f"InterpreterError STDOUT: {e.stdout}")
            if hasattr(e, "stderr") and e.stderr:
                logger.error(f"InterpreterError STDERR: {e.stderr}")
            raise CodeExecutionError(error_message) from e
        except Exception as e:
            error_message = f"An unexpected error occurred during code execution for {output_filename}: {e}"
            logger.error(error_message, exc_info=True)  # Log with traceback
            raise CodeExecutionError(error_message) from e
    finally:
        tempfile.tempdir = original_tempdir
        logger.info(
            f"Restored tempfile.tempdir to: {original_tempdir if original_tempdir else 'system default'}"
        )

    # Final check for the output file existence (belt-and-suspenders)
    if not actual_wav_path.exists() or not actual_wav_path.is_file():
        # This should ideally not be reached if the checks above are comprehensive
        raise FileNotFoundError(
            f"Generated .wav file not found at final path after all checks: {actual_wav_path}."
        )

    logger.info(f"Successfully produced WAV file: {actual_wav_path}")
    return actual_wav_path


if __name__ == "__main__":
    import json

    logging.basicConfig(level=logging.DEBUG)
    logger.info("Testing exec_env.py...")

    # Ensure settings are minimally available for paths
    if not hasattr(settings, "DEFAULT_OUT_DIR"):

        class DummySettings:
            DEFAULT_OUT_DIR = Path("./temp_output_exec_env_test")
            DEFAULT_SR = 48000

        settings = DummySettings()  # type: ignore
        settings.DEFAULT_OUT_DIR.mkdir(parents=True, exist_ok=True)

    # Test code that directly writes a wav file
    sample_code = """
import numpy as np
import soundfile as sf
from phonosyne import settings

# Get the output filename from the provided variables
wav_path = output_filename

frequency = 440.0
amplitude = 0.5

# Use settings.DEFAULT_SR and duration from variables
sample_rate = settings.DEFAULT_SR
t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False)
wave = amplitude * np.sin(2 * np.pi * frequency * t)

# Write the file directly
sf.write(wav_path, wave, sample_rate, subtype='FLOAT')
"""

    test_output_filename = "test_sine.wav"
    try:
        logger.info("\n--- Testing code execution ---")
        dummy_recipe_json = json.dumps(
            {
                "effect_name": "test_sine",
                "duration": 1.0,
                "description": "Test sine wave generation",
            }
        )

        generated_wav = run_code(
            sample_code,
            output_filename=test_output_filename,
            recipe_duration=1.0,
        )

        logger.info(f"Generated audio file: {generated_wav}")
        assert generated_wav.exists()
        assert generated_wav.stat().st_size > 0
        logger.info(f"File size: {generated_wav.stat().st_size} bytes. Test passed.")
        # Manual cleanup needed for file in settings.DEFAULT_OUT_DIR / "exec_env_output"
    except Exception as e:
        logger.error(f"Error in execution test: {e}", exc_info=True)

    print(
        f"\nFinished exec_env.py tests. Please check {settings.DEFAULT_OUT_DIR / 'exec_env_output'} for generated files and clean up manually."
    )
